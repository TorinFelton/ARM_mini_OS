KMD
00000000:             ; INCLUDE ../os/OS_header.s
00000000:             ; ; v9.5
00000000:             ; ; Changelog:
00000000:             ; ; - Changed init -> SVC_init
00000000:             ; ;   - 'init' will now be a USER label, denoting the beginning of the program
00000000:             ; ;   - The user should add the threads (in an atomic block) in the init routine
00000000:             ; ;   - They should then exit the init thread.
00000000:             ; ; - Added SVCs for creating atomic block (disables interrupts)
00000000:             ; ; - Added SVC for exiting thread
00000000:             ; ; - Added SVC for creating new thread
00000000:             ; 
00000000:             ; Max_SVC EQU 15
00000000:             ; call_write_string EQU 0
00000000:             ; call_write_char EQU 1
00000000:             ; call_clear_display EQU 2
00000000:             ; call_hang EQU 3
00000000:             ; call_wait_ms EQU 4
00000000:             ; call_load_port_B EQU 5
00000000:             ; call_BEGIN_ATOMIC_BLOCK EQU 6
00000000:             ; call_END_ATOMIC_BLOCK EQU 7
00000000:             ; call_add_thread_to_pool EQU 8
00000000:             ; call_exit_thread EQU 9
00000000:             ; call_yield EQU 10
00000000:             ; call_divider_IN_send_data EQU 11
00000000:             ; call_divider_IN_send_inst EQU 12
00000000:             ; call_divider_OUT_recieve_state EQU 13
00000000:             ; call_divider_OUT_recieve_data EQU 14
00000000:             ; 
00000000:             ; INTERRUPT_enable_timer_compare EQU 1
00000000:             ; 
00000000:             ; disable_interrupts EQU &80
00000000:             ; 
00000000:             ; base_IO_address EQU &10000000
00000000:             ; OFFSET_enable_interrupts_port EQU &1C 
00000000:             ; 
00000000:             ; port_B_address EQU &10000004
00000000:             ; timer_compare_port EQU &1000000C
00000000:             ; 
00000000:             ; 
00000000:             ; 
00000000: EA000006    ; B SVC_init
00000004: EA000017    ; B undefined_instruction
00000008: EA000017    ; B SVC_handler
0000000C: E1A00000    ; NOP
00000010: E1A00000    ; NOP
00000014: E1A00000    ; NOP
00000018: EA00019A    ; B interrupt_handler
0000001C: EAFFFFFE    ; B . ; fast interrupts
00000020:             ; 
00000020:             ; SVC_init
00000020: E28FDF45    ;     ADRL SP, supervisor_stack_top ; set supervisor sp (R13) to top of stack allocation
00000024: E28DDB01    ; 
00000028:             ;     
00000028: EB000144    ;     BL TS_BUFFER_setup ; set up thread stack buffer pointers to enable enqueue, dequeue
0000002C:             ; 
0000002C:             ;     ; switch to interrupt mode first to set up stack etc.
0000002C: E3A0E0D2    ;     MOV R14, #BM_interrupt_mode
00000030: E12FF00E    ;     MSR CPSR, R14 ; switch to interrupt mode
00000034:             ; 
00000034: E28FDFBF    ;     ADRL SP, interrupt_stack_top ; set up interrupt mode stack
00000038:             ; 
00000038:             ; 
00000038: E3A00001    ;     MOV R0, #INTERRUPT_enable_timer_compare
0000003C: E3A01201    ;     MOV R1, #base_IO_address
00000040: E281101C    ;     ADD R1, R1, #OFFSET_enable_interrupts_port
00000044: E5010000    ;     STR R0, [R1] ; enable timer compare interrupt
00000048:             ; 
00000048:             ; 
00000048: E3A00000    ;     MOV R0, #0
0000004C: E3A01000    ;     MOV R1, #0 ; reset registers to 0 for convention
00000050:             ; 
00000050: E3A0E0D0    ;     MOV R14, #BM_user_mode ; set up user mode
00000054: E3CEE080    ;     BIC R14, R14, #disable_interrupts  ; Clear the disable interrupts bit, thus ENABLING them.
00000058:             ;     
00000058: E16FF00E    ;     MSR SPSR, R14 ; switch to user mode
0000005C: E28FED1E    ;     ADRL R14, init ; set up entry point of user program
00000060: E28EE000    ; 
00000064: E1B0F00E    ;     MOVS PC, R14 ; return to user code
00000068:             ; 
00000068:             ; 
00000068:             ; undefined_instruction
00000068: EAFFFFFE    ;     B .
0000006C:             ; 
0000006C:             ; SVC_handler
0000006C: E92D4000    ;     PUSH {LR}
00000070: E51EE004    ;     LDR R14, [LR, #-4]
00000074: E3CEE4FF    ;     BIC R14, R14, #&FF000000
00000078:             ; 
00000078: E35E000F    ;     CMP R14, #Max_SVC
0000007C:             ;     
0000007C: B08FE10E    ; table_calc    ADDLT R14, PC, R14, LSL #2
00000080: B59EF004    ;     LDRLT PC, [R14, #(SVC_jump_table - (table_calc + 8))]
00000084: EAFFFFF7    ;     B undefined_instruction
00000088: 000000C4    ; SVC_jump_table DEFW SVC_0 ; print string
0000008C: 000000CC    ;                DEFW SVC_1 ; print char
00000090: 000000D4    ;                DEFW SVC_2 ; clear display
00000094: 000000E8    ;                DEFW SVC_3 ; hang prog
00000098: 000000EC    ;                DEFW SVC_4 ; wait variable amount of ms
0000009C: 000000F4    ;                DEFW SVC_5 ; load Port B into R0.
000000A0: 00000108    ;                DEFW SVC_6 ; disable interrupts
000000A4: 00000120    ;                DEFW SVC_7 ; enable interrupts
000000A8: 00000138    ;                DEFW SVC_8 ; add thread to pool
000000AC: 0000017C    ;                DEFW SVC_9 ; exit current thread and switch to next
000000B0: 00000194    ;                DEFW SVC_10 ; yield to cpu
000000B4: 000001D8    ;                DEFW SVC_11 ; load R0 into 2000_0000 (data input for divider)
000000B8: 000001EC    ;                DEFW SVC_12 ; load R0 into 2000_0006 (control input for divider)
000000BC: 00000200    ;                DEFW SVC_13 ; load 2000_0006 into R0 (state output for divider)
000000C0: 00000214    ;                DEFW SVC_14 ; load 2000_0004 into R0 (result output for divider)
000000C4:             ; SVC_0
000000C4:             ;     ; print string
000000C4: EB00018F    ;     BL write_string
000000C8: EA000059    ;     B SVC_exit
000000CC:             ; 
000000CC:             ; SVC_1
000000CC:             ;     ; print char
000000CC: EB000195    ;     BL write_character
000000D0: EA000057    ;     B SVC_exit
000000D4:             ; 
000000D4:             ; SVC_2
000000D4: E92D0001    ;     PUSH {R0}
000000D8: E3A00001    ;     MOV R0, #&01
000000DC: EB000191    ;     BL write_character
000000E0: E8BD0001    ;     POP {R0}
000000E4: EA000052    ;     B SVC_exit
000000E8:             ; 
000000E8:             ; SVC_3
000000E8:             ;     ; hang program forever
000000E8: EAFFFFFE    ;     B .
000000EC:             ; 
000000EC:             ; SVC_4
000000EC:             ;     ; wait variable amount of ms (R0 is input)
000000EC: EB0001AC    ;     BL wait_ms
000000F0: EA00004F    ;     B SVC_exit
000000F4:             ; 
000000F4:             ; SVC_5
000000F4:             ;     ; load Port B into R0
000000F4: E92D0002    ;     PUSH {R1}
000000F8: E3A01241    ;     MOV R1, #port_B_address
000000FC: E5510000    ;     LDRB R0, [R1]
00000100: E8BD0002    ;     POP {R1}
00000104: EA00004A    ;     B SVC_exit
00000108:             ; 
00000108:             ; SVC_6
00000108:             ;     ; Disable interrupts in user mode
00000108: E92D0001    ;     PUSH {R0}
0000010C:             ; 
0000010C: E14F0000    ;     MRS R0, SPSR
00000110: E3800080    ;     ORR R0, R0, #disable_interrupts ; enable the 'disable interrupts' bit
00000114: E16FF000    ;     MSR SPSR, R0
00000118:             ; 
00000118: E8BD0001    ;     POP {R0}
0000011C: EA000044    ;     B SVC_exit ; will save the SPSR back to the CPSR allowing above^
00000120:             ; 
00000120:             ; SVC_7
00000120:             ;     ; Enable interrupts in user mode
00000120: E92D0001    ;     PUSH {R0}
00000124:             ; 
00000124: E14F0000    ;     MRS R0, SPSR
00000128: E3C00080    ;     BIC R0, R0, #disable_interrupts ; disable the 'disable interrupts' bit
0000012C: E16FF000    ;     MSR SPSR, R0
00000130:             ; 
00000130: E8BD0001    ;     POP {R0}
00000134: EA00003E    ;     B SVC_exit ; will save the SPSR back to the CPSR allowing above^
00000138:             ; 
00000138:             ; SVC_8
00000138:             ;     ; FUNCTION: Add program onto the context switch pool
00000138:             ;     ; INPUT: R0 = pointer to beginning of program, R1 = pointer to program's stack
00000138:             ;     ; OUTPUT: None
00000138:             ;     ; DESCRIPTION: Takes program information as input and sets up information to include progra
                      ; m
00000138:             ;     ; in context switching.
00000138:             ;     ; This is REQUIRED to allow the program to be included in the time slicing.
00000138:             ;     
00000138: E92D003D    ;     PUSH {R0, R2-R5}
0000013C:             ; 
0000013C: E1A0500D    ;     MOV R5, SP
00000140:             ; 
00000140:             ;     ; Create a fresh user mode CPSR and store for now
00000140: E3A020D0    ;     MOV R2, #BM_user_mode
00000144: E3C22080    ;     BIC R2, R2, #disable_interrupts ; enable interrupts so the user program can be context swit
                      ; ched
00000148:             ; 
00000148:             ;     ; -------------- SETUP thread stack for program --------------
00000148: E1A0D001    ;     MOV SP, R1 ; SP = program's stack that was input
0000014C:             ; 
0000014C: E3A03000    ;     MOV R3, #0
00000150: E3A0400F    ;     MOV R4, #15
00000154:             ;     ; Push blank (0) data for R0-R14 incl.
00000154:             ;     setup_TS_keep_pushing_blank
00000154: E92D0008    ;         PUSH {R3}
00000158: E2544001    ;         SUBS R4, R4, #1
0000015C: 1AFFFFFC    ;         BNE setup_TS_keep_pushing_blank
00000160:             ; 
00000160:             ; 
00000160: E92D0001    ;     PUSH {R0} ; push pointer to beginning of program as the PC value
00000164: E92D0004    ;     PUSH {R2} ; push CPSR
00000168:             ; 
00000168: E1A0000D    ;     MOV R0, SP ; Input of R0 is OVERWRITTEN (restored by the stack pop though)
0000016C: EB0000FA    ;     BL TS_BUFFER_enqueue ; enqueue updated SP of prog2
00000170:             ;     ; --------------- END SETUP  ----------------
00000170:             ; 
00000170: E1A0D005    ;     MOV SP, R5 ; restore back to svc stack
00000174:             ; 
00000174: E8BD003D    ;     POP {R0, R2-R5}
00000178: EA00002D    ;     B SVC_exit
0000017C:             ; 
0000017C:             ; SVC_9
0000017C: E8BD4000    ;     POP {LR} ; LR is pushed by jump table
00000180:             ;     ; we need to pop it as we won't use SVC_exit (which normally pops it)
00000180:             ; 
00000180:             ;     ; exit current thread
00000180:             ;     ; This is done by moving into interrupt mode, branching to the context switch BUT
00000180:             ;     ; skipping the 'state saving' part of the switch.
00000180:             ;     ; Effectively switch to next thread without saving (and enqueueing) 
00000180:             ;     ; current one, therefore 'ending' it.
00000180:             ; 
00000180: E3A0E0D2    ;     MOV R14, #BM_interrupt_mode
00000184: E12FF00E    ;     MSR CPSR, R14 ; switch to interrupt mode
00000188:             ; 
00000188: EA00014F    ;     B ISR_context_switch_nosave
0000018C:             ;     ; no need for BL as we're not coming back
0000018C:             ; 
0000018C:             ;     ; no need for SVC_exit as the above branch will restore the state of the next available thr
                      ; ead.
0000018C:             ; 
0000018C:             ; 
0000018C:             ; 
0000018C: 00000000    ; LOCALTEMP_passLR DEFW 0
00000190: 00000000    ; LOCALTEMP_passSPSR DEFW 0
00000194:             ; 
00000194:             ; SVC_10
00000194:             ;     ; yield to cpu
00000194:             ;     ; effectively force a context switch
00000194:             ;     ; problem: how do we do LR_irq = LR_svc so 
00000194:             ;     ;          that we correctly return to the right place after the yield
00000194:             ;     ; current solution: a lot of mode switching
00000194:             ;     
00000194: E8BD4000    ;     POP {LR}  ; restore original LR as it's been overwritten by jump table
00000198:             ;     ; also pop it off stack as it won't be popped by SVC_exit (because we aren't branching ther
                      ; e)
00000198:             ; 
00000198: E92D0001    ;     PUSH {R0} ; to use as scratch register. NOTE: pushed to SP_svc
0000019C:             ; 
0000019C: E24F0018    ;     ADR R0, LOCALTEMP_passLR
000001A0: E500E000    ;     STR LR, [R0] ; store LR_svc at LOCALTEMP_passLR
000001A4:             ;     ; LR_svc (R14) can now be overwritten:
000001A4: E14FE000    ;     MRS R14, SPSR
000001A8: E580E004    ;     STR R14, [R0, #(LOCALTEMP_passSPSR-LOCALTEMP_passLR)] ; store SPSR at LOCALTEMP_passSPSR
000001AC:             ; 
000001AC: E3A0E0D2    ;     MOV R14, #BM_interrupt_mode
000001B0: E12FF00E    ;     MSR CPSR, R14 ; switch to interrupt mode
000001B4:             ; 
000001B4: E510E000    ;     LDR LR, [R0] ; LR_irq = LOCALTEMP_passSVC
000001B8: E5900004    ;     LDR R0, [R0, #(LOCALTEMP_passSPSR-LOCALTEMP_passLR)]
000001BC: E16FF000    ;     MSR SPSR, R0 ; SPSR_irq = LOCALTEMP_passSPSR
000001C0:             ; 
000001C0: E3A000D3    ;     MOV R0, #BM_svc_mode
000001C4: E12FF000    ;     MSR CPSR, R0
000001C8:             ;     
000001C8: E8BD0001    ;     POP {R0} ; restore R0
000001CC:             ; 
000001CC: E3A0E0D2    ;     MOV R14, #BM_interrupt_mode
000001D0: E12FF00E    ;     MSR CPSR, R14 ; switch to interrupt mode
000001D4:             ;     
000001D4: EA000135    ;     B ISR_context_switch ; now force a context switch
000001D8:             ; 
000001D8:             ; HD_divider_io_base EQU &2000_0000
000001D8:             ; OFFSET_HD_divider_io_control EQU &6
000001D8:             ; OFFSET_HD_divider_io_result EQU &4
000001D8:             ; OFFSET_HD_divider_io_state EQU &6
000001D8:             ; 
000001D8:             ; 
000001D8:             ; SVC_11
000001D8:             ;     ; FUNCTION: Load R0 into divider data input
000001D8:             ;     ; INPUTS: R0
000001D8:             ;     ; OUTPUTS: None, R0 is untouched
000001D8:             ; 
000001D8: E92D0002    ;     PUSH {R1}
000001DC:             ; 
000001DC: E3A01202    ;     MOV R1, #HD_divider_io_base
000001E0: E5010000    ;     STR R0, [R1]
000001E4:             ; 
000001E4: E8BD0002    ;     POP {R1}
000001E8:             ; 
000001E8: EA000011    ;     B SVC_exit
000001EC:             ; 
000001EC:             ; SVC_12
000001EC:             ;     ; FUNCTION: Load R0 into divider control input
000001EC:             ;     ; INPUTS: R0
000001EC:             ;     ; OUTPUTS: none
000001EC:             ; 
000001EC: E92D0002    ;     PUSH {R1}
000001F0:             ; 
000001F0: E3A01202    ;     MOV R1, #HD_divider_io_base
000001F4: E5C10006    ;     STRB R0, [R1, #OFFSET_HD_divider_io_control]
000001F8:             ; 
000001F8: E8BD0002    ;     POP {R1}
000001FC: EA00000C    ;     B SVC_exit
00000200:             ; 
00000200:             ; SVC_13
00000200:             ;     ; FUNCTION: Load divider state into R0
00000200:             ;     ; INPUTS: none
00000200:             ;     ; OUTPUTS: R0 changed to divider state
00000200:             ; 
00000200: E92D0002    ;     PUSH {R1}
00000204:             ; 
00000204: E3A01202    ;     MOV R1, #HD_divider_io_base
00000208: E5D10006    ;     LDRB R0, [R1, #OFFSET_HD_divider_io_state]
0000020C:             ; 
0000020C: E8BD0002    ;     POP {R1}
00000210: EA000007    ;     B SVC_exit
00000214:             ; 
00000214:             ; SHIFT_first_half_result EQU 8 
00000214:             ; ; result = 2 bytes, therefore first half is 1 byte
00000214:             ; 
00000214:             ; SVC_14
00000214:             ;     ; FUNCTION: Load divider result into R0
00000214:             ;     ; INPUTS: none
00000214:             ;     ; OUTPUTS: R0 changed to divider result
00000214:             ; 
00000214: E92D0002    ;     PUSH {R1}
00000218:             ; 
00000218: E3A01202    ;     MOV R1, #HD_divider_io_base
0000021C: E5D10004    ;     LDRB R0, [R1, #OFFSET_HD_divider_io_result]
00000220: E1A00400    ;     LSL R0, R0, #SHIFT_first_half_result
00000224:             ; 
00000224:             ;     ; Get second half of result
00000224:             ;     ; NOTE: We are loading into R1 so as not to overwrite the first half
00000224:             ;     ; of the result that is stored in R0.
00000224: E5D11005    ;     LDRB R1, [R1, #(OFFSET_HD_divider_io_result + 1)]
00000228: E1800001    ;     ORR R0, R0, R1 ; combine both halves of the result
0000022C:             ; 
0000022C: E8BD0002    ;     POP {R1}
00000230: EAFFFFFF    ;     B SVC_exit
00000234:             ; 
00000234:             ; SVC_exit
00000234: E8FD8000    ;     POP {PC}^
00000238:             ; 
00000238:             ; DEFS 256
00000338: 00000000    ; interrupt_stack_top DEFW 0
0000033C:             ; 
0000033C:             ; DEFS 512
0000053C: 00000000    ; supervisor_stack_top DEFW 0
00000540:             ; 
00000540:             ; 
00000540:             ; 
00000540:             ; INCLUDE interrupts.s ; contains interrupt handler & routines
00000540:             ; ; v9.5
00000540:             ; ; Changelog:
00000540:             ; ; - Added ISR_context_switch_nosave label (used for exiting a thread)
00000540:             ; ; - Added context switching using thread's own stack to save its registers
00000540:             ; 
00000540:             ; 
00000540:             ; 
00000540:             ; INCLUDE timer_constants.s ; for timer status variables, minute/second times, etc.
00000540:             ; ; v7.0
00000540:             ; 
00000540:             ; TIMER_STATUS_counting EQU 0
00000540:             ; TIMER_STATUS_pause    EQU 1
00000540:             ; TIMER_STATUS_reset    EQU 2
00000540:             ; 
00000540:             ; TIMER_DISPLAY_sec_digit_0 EQU 19
00000540:             ; TIMER_DISPLAY_sec_digit_1 EQU 18
00000540:             ; 
00000540:             ; TIMER_DISPLAY_min_digit_0 EQU 7
00000540:             ; TIMER_DISPLAY_min_digit_1 EQU 6
00000540:             ; 
00000540:             ; minute_passed EQU 60
00000540:             ; second_passed EQU 10
00000540:             ; hundred_ms EQU 100
00000540:             ; INCLUDE ts_circ_buffer_util.s ; Functions & data for the thread stack pointer queue
00000540:             ; ; v1.0
00000540:             ; 
00000540:             ; 
00000540:             ; TS_BUFFER_MAX_CAPACITY EQU 3
00000540:             ; 
00000540:             ; TS_BUFFER_setup
00000540:             ;     ; FUNCTION: Setup pointers for TS buffer
00000540:             ;     ; Description: Should be called at OS setup stage.
00000540: E92D4003    ;     PUSH {R0-R1, LR}
00000544:             ; 
00000544:             ;     ; Set up pointers
00000544: E28F0F4E    ;     ADRL R0, TS_CIRC_BUFFER
00000548: E28F10AC    ;     ADR R1, TS_CIRC_BUFFER_HEAD
0000054C: E5010000    ;     STR R0, [R1]
00000550: E28F10A8    ;     ADR R1, TS_CIRC_BUFFER_TAIL
00000554: E5010000    ;     STR R0, [R1]
00000558:             ; 
00000558: E8BD8003    ;     POP {R0-R1, PC}
0000055C:             ; 
0000055C:             ; 
0000055C:             ; TS_BUFFER_enqueue
0000055C:             ;     ; FUNCTION: Enqueue a stack pointer to the thread stack buffer
0000055C:             ;     ; INPUT: R0 as the pointer to enqueue
0000055C:             ;     ; OUTPUT: None
0000055C:             ;     ; Description: Enqueues (circularly) stack pointer to buffer. Will NOT overwrite if full.
0000055C:             ; 
0000055C: E92D401E    ;     PUSH {R1-R4, LR}
00000560:             ; 
00000560: E28F1090    ;     ADR R1, TS_CIRC_BUFFER_LENGTH
00000564: E5111000    ;     LDR R1, [R1]
00000568: E3A02003    ;     MOV R2, #TS_BUFFER_MAX_CAPACITY
0000056C: E1510002    ;     CMP R1, R2
00000570: A8BD801E    ;         POPGE {R1-R4, PC} ; exit routine; don't enqueue if buffer is full
00000574:             ; 
00000574:             ;     ; ------ 1. & 2. ------
00000574: E28F1080    ;     ADR R1, TS_CIRC_BUFFER_HEAD
00000578: E5112000    ;     LDR R2, [R1] ; load pointer from TS_CIRC_BUFFER_HEAD
0000057C: E4020004    ;     STR R0, [R2], #-4               ; -4 as we are word-addressing 
00000580:             ; 
00000580:             ;     ; ----- 3. ------
00000580: E28F30FC    ;     ADR R3, TS_CIRC_BUFFER
00000584: E2434060    ;     SUB R4, R3, #(32*TS_BUFFER_MAX_CAPACITY)
00000588: E1520004    ;     CMP R2, R4
0000058C: B1A02003    ;     MOVLT R2, R3 ; if R2 is out of range, change R2 to point back to the top (TS_CIRC_BUFFER)
00000590:             ; 
00000590:             ; 
00000590: E5012000    ;     STR R2, [R1] ; Store new head pointer back to TS_CIRC_BUFFER_HEAD
00000594:             ; 
00000594: E28F105C    ;     ADR R1, TS_CIRC_BUFFER_LENGTH
00000598: E5112000    ;     LDR R2, [R1]
0000059C: E2822001    ;     ADD R2, R2, #1 ; +1 to amount of enqueued items (length)
000005A0: E5012000    ;     STR R2, [R1]
000005A4:             ; 
000005A4:             ;     
000005A4: E8BD801E    ;     POP {R1-R4, PC}
000005A8:             ; 
000005A8:             ; TS_BUFFER_dequeue
000005A8:             ;     ; FUNCTION: Dequeue thread stack pointer
000005A8:             ;     ; INPUT: None
000005A8:             ;     ; OUTPUT: R0 overwritten with next thread stack pointer
000005A8:             ; 
000005A8: E92D401E    ;     PUSH {R1-R4, LR}
000005AC:             ; 
000005AC: E28F1044    ;     ADR R1, TS_CIRC_BUFFER_LENGTH
000005B0: E5111000    ;     LDR R1, [R1]
000005B4: E3A02000    ;     MOV R2, #0
000005B8: E1510002    ;     CMP R1, R2
000005BC:             ;         ; Return 0 (empty value) if queue is empty
000005BC: 03A00000    ;         MOVEQ R0, #0 ; Return value of 0 as a default
000005C0: 08BD801E    ;         POPEQ {R1-R4, PC} ; exit routine early to avoid code below
000005C4:             ; 
000005C4:             ;     ; ------ 1. & 2. ------
000005C4: E28F1034    ;     ADR R1, TS_CIRC_BUFFER_TAIL
000005C8: E5112000    ;     LDR R2, [R1] ; load pointer from TS_CIRC_BUFFER_TAIL
000005CC: E4120004    ;     LDR R0, [R2], #-4
000005D0:             ; 
000005D0:             ;     ; ----- 3. ------
000005D0: E28F30AC    ;     ADR R3, TS_CIRC_BUFFER
000005D4: E2434060    ;     SUB R4, R3, #(32*TS_BUFFER_MAX_CAPACITY)
000005D8: E1520004    ;     CMP R2, R4
000005DC: B1A02003    ;     MOVLT R2, R3 ; if R2 is out of range, change R2 to point back to the top (TS_CIRC_BUFFER)
000005E0:             ;     
000005E0:             ; 
000005E0: E5012000    ;     STR R2, [R1] ; Store new tail pointer back to TS_CIRC_BUFFER_TAIL
000005E4:             ; 
000005E4: E28F100C    ;     ADR R1, TS_CIRC_BUFFER_LENGTH
000005E8: E5112000    ;     LDR R2, [R1]
000005EC: E2422001    ;     SUB R2, R2, #1 ; -1 to amount of enqueued items (length)
000005F0: E5012000    ;     STR R2, [R1]
000005F4:             ; 
000005F4: E8BD801E    ;     POP {R1-R4, PC}
000005F8:             ; 
000005F8: 00000000    ; TS_CIRC_BUFFER_LENGTH DEFW 0
000005FC: 00000000    ; TS_CIRC_BUFFER_HEAD DEFW 0
00000600: 00000000    ; TS_CIRC_BUFFER_TAIL DEFW 0
00000604:             ; DEFS 128
00000684: 00000000    ; TS_CIRC_BUFFER DEFW 0
00000688:             ; 
00000688:             ; interrupt_active_port_offset EQU &18
00000688:             ; timer_compare_interrupt_active EQU &1
00000688:             ; timer_counter_port EQU &10000008
00000688:             ; 
00000688:             ; FPGA_PIO_base_address EQU &2000_0000
00000688:             ; OFFSET_FPGA_PIO_kb_port_data EQU &2
00000688:             ; OFFSET_FPGA_PIO_kb_port_control EQU &3
00000688:             ; 
00000688:             ; OFFSET_PIO_kb_port_IO_control EQU 1
00000688:             ; 
00000688:             ; 
00000688:             ; interrupt_handler
00000688: E24FDFD6    ;     ADRL SP, interrupt_stack_top
0000068C:             ;         ; When a context switch happens, the interrupt SP is changed to the thread's SP
0000068C:             ;         ; Therefore we need to make sure the SP_irq uses the interrupt stack at first, to avoid
0000068C:             ;         ; corrupting a thread SP.
0000068C:             ;         ; It is fine to set this to the static memory location 'interrupt_stack_top' 
0000068C:             ;         ; as nothing useful should be stored on the interrupt stack after/before an interrupt.
0000068C:             ; 
0000068C: E24EE004    ;     SUB LR, LR, #4 ; LR points ahead when interrupt happens so we need to correct it
00000690: E92D4003    ;     PUSH {R0-R1, LR}
00000694:             ; 
00000694:             ;     
00000694: E3A00201    ;     MOV R0, #base_IO_address ; from OS_header.s, which this must be included into
00000698: E2800018    ;     ADD R0, R0, #interrupt_active_port_offset
0000069C: E5501000    ;     LDRB R1, [R0]
000006A0:             ; 
000006A0: E2111001    ;     ANDS R1, R1, #timer_compare_interrupt_active
000006A4: 18BD4003    ;         POPNE {R0-R1, LR} ; restore registers to be saved for context switch
000006A8: 1A000000    ;         BNE ISR_context_switch ; no link as we want to preserve LR_irq (user prog PC)
000006AC:             ; 
000006AC: E8FD8003    ;     POP {R0-R1, PC}^ ; restore & return
000006B0:             ; 
000006B0:             ; 
000006B0:             ; ISR_context_switch
000006B0:             ;     ; Set up timer for next interrupt and execute context switch
000006B0:             ; 
000006B0:             ;     ; get user SP and push onto interrupt stack
000006B0: E96D2000    ;     PUSH {SP}^
000006B4: E51DD000    ;     LDR SP, [SP]
000006B8:             ;         ; Why not POP {SP}? Because this will decrement SP_usr and not SP_irq.
000006B8:             ;         ; SP_irq is forgotten at this point, because when we interrupt again we will reset SP_i
                      ; rq to
000006B8:             ;         ; 'interrupt_stack_top', starting at the beginning again.
000006B8:             ; 
000006B8: E96D7FFF    ;     PUSH {R0-LR}^ ; store R0-LR_usr onto the user program's stack
000006BC: E14F0000    ;     MRS R0, SPSR ; get user's CPSR
000006C0: E92D4001    ;     PUSH {R0, LR} ; store CPSR and PC to return to (LR_irq)
000006C4:             ; 
000006C4: E1A0000D    ;     MOV R0, SP
000006C8: EBFFFFA3    ;     BL TS_BUFFER_enqueue ; enqueue this thread stack for later
000006CC:             ; 
000006CC:             ;     ISR_context_switch_nosave
000006CC:             ;         ; Why have this label?
000006CC:             ;         ; This label enables us to skip the 'state saving' section of the context switch.
000006CC:             ;         ; It is used when we want to CLOSE a thread (therefore never switch to it again).
000006CC:             ;         ; Thus we do NOT save the thread's info back, we just switch to another.
000006CC:             ; 
000006CC:             ; 
000006CC:             ;     ; -------------- SETUP NEXT CONTEXT SWITCH INTERRUPT -----------
000006CC:             ; 
000006CC:             ;     TIME_PER_THREAD EQU 2;ms
000006CC:             ; 
000006CC: E3A012C1    ;     MOV R1, #timer_compare_port
000006D0: E5510000    ;     LDRB R0, [R1] ; load current time
000006D4: E2800002    ;     ADD R0, R0, #TIME_PER_THREAD ; add ms to wait for
000006D8: E5410000    ;     STRB R0, [R1]
000006DC:             ; 
000006DC:             ; 
000006DC:             ;     ; ACKNOWLEDGE THE TIMER INTERRUPT
000006DC: E3A00201    ;     MOV R0, #base_IO_address ; from OS_header.s, which this will be included into
000006E0: E2800018    ;     ADD R0, R0, #interrupt_active_port_offset
000006E4: E5501000    ;     LDRB R1, [R0]
000006E8: E3C11001    ;     BIC R1, R1, #timer_compare_interrupt_active ; clear timer interrupt bit
000006EC: E5401000    ;     STRB R1, [R0]
000006F0:             ;     ; STORE ACKNOWLEDGEMENT
000006F0:             ; 
000006F0:             ;     ; -------------- End of Setup -----------
000006F0:             ; 
000006F0:             ;     
000006F0:             ;     ; -------------- Restore next thread's state ----------------
000006F0: EBFFFFAC    ;     BL TS_BUFFER_dequeue ; R0 = new thread stack
000006F4: E1A0D000    ;     MOV SP, R0
000006F8:             ; 
000006F8: E8BD4001    ;     POP {R0, LR} ; get SPSR, PC to return to
000006FC: E16FF000    ;     MSR SPSR_cxsf, R0
00000700: E8FD7FFF    ;     POP {R0-LR}^ ; pop R0-LR_usr 
00000704:             ; 
00000704: E1B0F00E    ;     MOVS PC, LR ; return PC to new thread and restore its status
00000708:             ; INCLUDE standard_io.s
00000708:             ; ; v7.0
00000708:             ; ; Changelog:
00000708:             ; ; - Changed write_char so that the input, R0, holds the ASCII value and not a pointer to an ASC
                      ; II value
00000708:             ; ; - Changed write_string to accommodate above change
00000708:             ; 
00000708:             ; INCLUDE character_definitions.s 
00000708:             ; ; v3.0
00000708:             ; ; Changelog:
00000708:             ; _NEWLINE EQU &0A
00000708:             ; _CLEAR_DISPLAY EQU &01
00000708:             ; NEWLINE_INSTRUCTION EQU &A8
00000708:             ; ; includes special characters such as NEWLINE for translation to an LCD newline
00000708:             ; 
00000708:             ; INCLUDE bit_mask_definitions.s
00000708:             ; ; v7.0
00000708:             ; ; Changelog:
00000708:             ; ; - Add system mode bm
00000708:             ; ; - Added BM_debounce_register_press & unpress. These are for the values to check our shifting 
                      ; byte-buffers, 
00000708:             ; ;       to see if we consider a button pressed or unpressed. 
00000708:             ; 
00000708:             ; BM_LED_Enable EQU &10 ; Bit for enabling/disabling LEDs on board
00000708:             ; BM_Status EQU &80     ; Status, bit 7, of port A
00000708:             ; BM_R_NOTW EQU &4      ; R/-W of port B
00000708:             ; BM_RS EQU &2          ; RS of port B
00000708:             ; BM_Enable_Interface EQU &1 ; Enable bit of port B
00000708:             ; BM_button_upper EQU &40 ; Upper button enable bit of port B
00000708:             ; BM_button_lower EQU &80 ; Lower button enable bit of port B
00000708:             ; 
00000708:             ; BM_svc_mode EQU &D3
00000708:             ; BM_user_mode EQU &D0
00000708:             ; BM_interrupt_mode EQU &D2 ; interrupt mode with IRQ and FIQ disabled
00000708:             ; BM_BIC_for_usr_mode EQU &4
00000708:             ; 
00000708:             ; BM_set_output_kb_matrix_wires EQU &F0
00000708:             ; BM_isolate_key_value EQU &F0
00000708:             ; BM_kb_enable_1_4_7_ASTERISK EQU &80
00000708:             ; BM_kb_enable_2_5_8_0 EQU &40
00000708:             ; BM_kb_enable_3_6_9_HASH EQU &20
00000708:             ; 
00000708:             ; BM_KB_top_row_pressed EQU &1
00000708:             ; BM_KB_bottom_row_pressed EQU &8
00000708:             ; 
00000708:             ; BM_debounce_register_press EQU &FF
00000708:             ; BM_debounce_register_unpress EQU &00
00000708:             ; ; includes bit masks for port A/B configuration
00000708:             ; 
00000708:             ; Port_A EQU &10000000
00000708:             ; timer_counter_port EQU &10000008
00000708:             ; 
00000708:             ; ; --------------- FUNCTIONS -----------------
00000708:             ; write_string
00000708:             ;     ; CHANGED (22nd March, 2023, Exercise 7): Change write_string to use write_char with R0 val
                      ; ue (not pointer)
00000708:             ;     ; DESCRIPTION: Takes a pointer to a string and outputs it entirely, stopping when a 0 is fo
                      ; und. Uses 'write_character'.
00000708:             ;     ; INPUT: R0 = Pointer to first char of string.
00000708:             ;     ; All registers are restored after usage (including original inputs)
00000708: E92D4003    ;     PUSH {R0, R1, LR}
0000070C:             ; 
0000070C: E1A01000    ;     MOV R1, R0 ; R1 is now going to be used as a pointer to the char to print
00000710:             ;     
00000710:             ;     print_loop 
00000710: E4D10001    ;         LDRB R0, [R1], #1    
00000714: E3500000    ;         CMP R0, #0
00000718: 0A000001    ;         BEQ end_print_loop ; end of string
0000071C: EB000001    ;         BL write_character
00000720: EAFFFFFA    ;         B print_loop
00000724:             ;     end_print_loop
00000724:             ; 
00000724: E8BD8003    ;     POP  {R0, R1, PC}
00000728:             ; 
00000728:             ; write_character
00000728:             ;     ; CHANGED (22nd March, 2023, Exercise 7): Change write_char input R0 to hold char value (no
                      ; t pointer)
00000728:             ;     ; DESCRIPTION: Takes an ASCII character and outputs to the LCD display.
00000728:             ;     ; INPUT: R0 = character value
00000728:             ;     ; All registers are restored after usage (including original inputs)
00000728: E92D41FE    ;     PUSH {R1-R8, LR}
0000072C:             ; 
0000072C: E3A04201    ;     MOV R4, #Port_A
00000730:             ; 
00000730:             ;     poll_LCD
00000730: E5D41004    ;         LDRB R1, [R4, #4]
00000734: E3811004    ;         ORR R1, R1, #BM_R_NOTW ;  R/-W = 1
00000738: E3C11002    ;         BIC R1, R1, #BM_RS ; RS=0
0000073C:             ; 
0000073C:             ; 
0000073C: E3811001    ;         ORR R1, R1, #BM_Enable_Interface  ; E = 1
00000740: E5C41004    ;         STRB R1, [R4, #4]
00000744:             ; 
00000744: E5545000    ;         LDRB R5, [R4]   ; Load A into R5
00000748:             ; 
00000748: E3C11001    ;         BIC R1, R1, #BM_Enable_Interface  ; E = 0
0000074C: E5C41004    ;         STRB R1, [R4, #4]
00000750:             ; 
00000750: E2053080    ;         AND R3, R5, #BM_Status ; check the status, bit 7
00000754:             ; 
00000754: E3530000    ;         CMP R3, #0 ; Compare to see if status is clear
00000758: 1AFFFFF4    ;         BNE poll_LCD   ; bit 7 of status byte is high
0000075C:             ; 
0000075C:             ;     write
0000075C: E3811002    ;         ORR R1, R1, #BM_RS ; RS=1
00000760: E3C11004    ;         BIC R1, R1, #BM_R_NOTW ; R/-W =bit 0
00000764: E5C41004    ;         STRB R1, [R4, #4]
00000768:             ; 
00000768:             ;         ;LDRB R6, [R0] ; Load character from pointer
00000768:             ;         ; CHANGED (22nd March, 2023, Exercise 7): Change write_char input R0 to hold char value
                      ;  (not pointer)
00000768:             ; 
00000768: E1A06000    ;         MOV R6, R0 ; copy input character
0000076C:             ; 
0000076C: E356000A    ;         CMP R6, #_NEWLINE ; ASCII NEWLINE, needs to replaced with LCD's newline instruction
00000770: 1A000001    ;         BNE skip_newline
00000774:             ;             ; We have a new line character
00000774: E3A060A8    ;             MOV R6, #NEWLINE_INSTRUCTION
00000778: E3C11002    ;             BIC R1, R1, #BM_RS ; RS = 0, write to control register to set cursor
0000077C:             ;         skip_newline
0000077C:             ; 
0000077C: E3560001    ;         CMP R6, #_CLEAR_DISPLAY ; 0x01
00000780: 1A000000    ;         BNE skip_clear_display
00000784:             ;             ; We have a clear display instruction
00000784: E3C11002    ;             BIC R1, R1, #BM_RS ; RS = 0, write to control register to send instruction
00000788:             ; 
00000788:             ;         skip_clear_display
00000788: E5446000    ;         STRB R6, [R4] ; put char from R6 in Port_A
0000078C:             ; 
0000078C: E3811001    ;         ORR R1, R1, #BM_Enable_Interface ; E = 1
00000790: E3C11010    ;         BIC R1, R1, #BM_LED_Enable ; LED ENABLE = 0
00000794: E5C41004    ;         STRB R1, [R4, #4] ; Store R1 with E=1
00000798:             ; 
00000798: E3C11001    ;         BIC R1, R1, #BM_Enable_Interface ; E =0
0000079C: E5C41004    ;         STRB R1, [R4, #4]
000007A0:             ; 
000007A0: E8BD81FE    ;     POP {R1-R8, PC}
000007A4:             ; 
000007A4:             ; 
000007A4:             ; wait_ms
000007A4:             ;     ; DESCRIPTION: Waits a variable amount of ms
000007A4:             ;     ; INPUT: R0 is the amount of ms to wait
000007A4: E92D407F    ;     PUSH {R0-R6, LR}
000007A8: E3A06281    ;     MOV R6, #timer_counter_port
000007AC: E1A05000    ;     MOV R5, R0 ; R5 <= time to wait in ms
000007B0:             ; 
000007B0:             ;     ; R0 = 'previous time'
000007B0:             ;     ; R1 = 'currently polled time'
000007B0:             ;     ; R3 = current diff
000007B0:             ;     ; R4 = counts total (we stop when >=R5)
000007B0: E5560000    ;     LDRB R0, [R6]
000007B4:             ;     poll_timer
000007B4: E5561000    ;         LDRB R1, [R6] ; load current time into R1
000007B8:             ;         
000007B8: E0413000    ;         SUB R3, R1, R0 ; By default, R3 = current_time-prev_time
000007BC: E1500001    ;         CMP R0, R1
000007C0:             ;         
000007C0:             ; 
000007C0:             ;         ; If R0 > R1, we have wrapped around
000007C0: DA000002    ;         BLE skip_wrap_case            
000007C4:             ;             ; time diff is 255-prev_time + current_time as it's wrapped around
000007C4: E3A030FF    ;             MOV R3, #255
000007C8: E0433000    ;             SUB R3, R3, R0 ; R3=255-prev_time
000007CC: E0833001    ;             ADD R3, R3, R1 ; R3 += current_time
000007D0:             ; 
000007D0:             ;         skip_wrap_case
000007D0: E0844003    ;         ADD R4, R4, R3
000007D4:             ; 
000007D4: E1A00001    ;         MOV R0, R1 ; current time saved to prev_time for next iteration
000007D8: E1540005    ;         CMP R4, R5
000007DC: BAFFFFF4    ;         BLT poll_timer
000007E0:             ;         
000007E0:             ; 
000007E0: E8BD807F    ;     POP {R0-R6, PC}
000007E4:             ; 
000007E4:             ; 
000007E4:             ; 
000007E4:             ; 
000007E4:             ; 
000007E4:             ; 
000007E4:             ; init
000007E4: EF000006    ;     SVC call_BEGIN_ATOMIC_BLOCK ; don't want to be interrupted while setting up the threads
000007E8:             ; 
000007E8: E28F0F4B    ;     ADRL R0, divider_program
000007EC: E28F1F49    ;     ADRL R1, divider_program_stack
000007F0: EF000008    ;     SVC call_add_thread_to_pool ; add divider program to thread pool to allow context switching
                      ;  to it
000007F4:             ; 
000007F4:             ; 
000007F4: E28F0F5D    ;     ADRL R0, prog2
000007F8: E28F1FA6    ;     ADRL R1, prog2_stack
000007FC: EF000008    ;     SVC call_add_thread_to_pool ; add prog2 to thread pool to allow context switching to it
00000800:             ; 
00000800: E28F0FAA    ;     ADRL R0, prog3
00000804: E28F1D0F    ;     ADRL R1, prog3_stack
00000808: EF000008    ;     SVC call_add_thread_to_pool ; add prog3
0000080C:             ;   
0000080C:             ; 
0000080C: EF000007    ;     SVC call_END_ATOMIC_BLOCK
00000810:             ; 
00000810: EF000009    ;     SVC call_exit_thread ; throw away setup thread
00000814:             ; 
00000814:             ; 
00000814:             ; INCLUDE program1.s
00000814: 00000000    ; divider_program_result DEFW 0
00000818:             ; 
00000818:             ; DEFS 256
00000918:             ; divider_program_stack
00000918:             ; 
00000918:             ; 
00000918:             ; HD_divider_io_RESET_INSTRUCTION EQU &1
00000918:             ; HD_divider_io_STARTDIV_INSTRUCTION EQU &2
00000918:             ; 
00000918:             ; HD_divider_io_state_OK EQU &2
00000918:             ; 
00000918:             ; ; As this is a word in total (input_A + input_B = 32 bits)
00000918:             ; ; we can just LDR from input_A address to capture both inputs
00000918: AF FF       ; input_A DEFB &AF, &FF
0000091A: 00 05       ; input_B DEFB &00, &05
0000091C:             ; ; If the above was written as a DEFW it would be more confusing
0000091C:             ; ; as it would be "DEFW &0500FFAF" to input 0xAFFF and 0x0005.
0000091C:             ; 
0000091C:             ; ; 0xAFFF divided by 0x0005 is 0x2333.
0000091C:             ; ; We verify this division is successful at the end.
0000091C:             ; ALIGN
0000091C:             ; 
0000091C:             ; 
0000091C:             ; divider_program
0000091C: E24FD00C    ;     ADRL SP, divider_program_stack
00000920:             ; 
00000920:             ;     ; some magic numbers to illustrate register state preservation
00000920: E3A02011    ;     MOV R2, #17
00000924: E3A03003    ;     MOV R3, #3
00000928:             ;     ; end of magic numbers
00000928:             ; 
00000928: E3A04000    ;     MOV R4, #0 ; R4 is a counter for how many times we poll the divider before it finishes    
0000092C: E24F5E12    ;     ADR R5, divider_program_result
00000930:             ; 
00000930: E3A06202    ;     MOV R6, #HD_divider_io_base
00000934:             ; 
00000934:             ; 
00000934: E24F0024    ;     ADR R0, input_A
00000938: E5100000    ;     LDR R0, [R0] ; first input is 0xAFAF, second is 0x0005
0000093C:             ;     ; two inputs stored in one 32 bit register: 0xAFAF0005 to divide 0xAFAF by 0x0005
0000093C:             ; 
0000093C: EF00000B    ;     SVC call_divider_IN_send_data ; load R0 into divider inputs
00000940:             ; 
00000940:             ; 
00000940: E3A00001    ;     MOV R0, #HD_divider_io_RESET_INSTRUCTION
00000944: EF00000C    ;     SVC call_divider_IN_send_inst ; send reset to divider
00000948:             ; 
00000948: E3A00002    ;     MOV R0, #HD_divider_io_STARTDIV_INSTRUCTION
0000094C: EF00000C    ;     SVC call_divider_IN_send_inst ; send 'start dividing' to divider
00000950:             ;     
00000950: EF00000A    ;     SVC call_yield ; Switch to other threads while we wait for division
00000954:             ;     
00000954:             ;     poll_HD_divider_io ; loop until we get OK (division is done) signal in divider_io_state byt
                      ; e
00000954: EF00000D    ;         SVC call_divider_OUT_recieve_state
00000958: E2100002    ;         ANDS R0, R0, #HD_divider_io_state_OK
0000095C:             ; 
0000095C: 0AFFFFFC    ;         BEQ poll_HD_divider_io
00000960:             ;     
00000960: EF00000E    ;     SVC call_divider_OUT_recieve_data ; get result of division into R0
00000964: E5050000    ;     STR R0, [R5]
00000968:             ; 
00000968: EF000009    ;     SVC call_exit_thread ; division is done.
0000096C:             ; 
0000096C:             ; INCLUDE program2.s
0000096C: 00000000    ; thing2 DEFW 0
00000970:             ; prog2
00000970: E28FDE12    ;     ADRL SP, prog2_stack
00000974: E24F0010    ;     ADR R0, thing2
00000978:             ; 
00000978:             ;     ; some magic numbers to illustrate register state preservation
00000978: E3A0200A    ;     MOV R2, #10
0000097C: E3A0300B    ;     MOV R3, #11
00000980: E3A0400C    ;     MOV R4, #12
00000984: E3A0500D    ;     MOV R5, #13
00000988:             ; 
00000988: E3A0800F    ;     MOV R8, #15 
0000098C:             ; 
0000098C:             ;     prog2_loop
0000098C: E2811001    ;         ADD R1, R1, #1
00000990: E5001000    ;         STR R1, [R0]
00000994: EAFFFFFC    ;         B prog2_loop
00000998:             ; 
00000998:             ; DEFS 256
00000A98:             ; prog2_stack
00000A98:             ; INCLUDE program3.s
00000A98:             ; CSWITCH_DELAY EQU 10
00000A98:             ; 
00000A98: 41 46 46 46 ; thread1_message DEFB "AFFF/5=\0"
00000A9C: 2F 35 3D 00 ; 
00000AA0: 0A 54 68 72 ; thread2_message DEFB "\nThread2:\0"
00000AA4: 65 61 64 32 ; 
00000AA8: 3A 00       ; 
00000AAC:             ; ALIGN
00000AAC:             ; 
00000AAC: 00002333    ; expected_div_result DEFW &2333
00000AB0:             ; 
00000AB0:             ; prog3
00000AB0: E28FDF45    ;     ADRL SP, prog3_stack
00000AB4: E24F7FAA    ;     ADR R7, divider_program_result
00000AB8: E24F8F55    ;     ADR R8, thing2
00000ABC: E24F5018    ;     ADR R5, expected_div_result
00000AC0: E5155000    ;     LDR R5, [R5]
00000AC4:             ; 
00000AC4:             ; 
00000AC4:             ;     prog3_loop
00000AC4: E3A0300A    ;         MOV R3, #CSWITCH_DELAY ; output every 10 times we are context switched to
00000AC8: E2533001    ;         prog3_wait SUBS R3, R3, #1
00000ACC: 1F00000A    ;             SVCNE call_yield ; yield to other threads if we don't want to output yet
00000AD0: 1AFFFFFC    ;             BNE prog3_wait
00000AD4:             ; 
00000AD4:             ;         ; interrupts disabled, cannot be context-switched here
00000AD4: EF000002    ;         SVC call_clear_display
00000AD8:             ; 
00000AD8: E24F0048    ;         ADR R0, thread1_message
00000ADC: EF000000    ;         SVC call_write_string
00000AE0:             ; 
00000AE0:             ;         ; dirty binary to ASCII hex code from internet: 
00000AE0:             ;         ; https://stackoverflow.com/questions/53400875/converting-integer-to-hex-string-in-arm-
                      ; assembly
00000AE0: E5174000    ;         LDR R4, [R7]
00000AE4: E1A04804    ;         LSL R4, R4, #16 ; Shift so correct part is output below
00000AE8: E3A06004    ;         MOV   r6, #4 ; CHANGED: only outputs 2 bytes of R4 (our div result is 16 bits)
00000AEC:             ;         output_thing1
00000AEC: E1A00E24    ;             MOV   r0, r4, LSR #28
00000AF0:             ; 
00000AF0: E1A04204    ;             MOV   r4, r4, LSL #4
00000AF4:             ; 
00000AF4: E2800030    ;             ADD   r0, r0, #48
00000AF8: E350003A    ;             CMP   r0, #58              
00000AFC: 22800007    ;             ADDHS r0, r0, #7           
00000B00: EF000001    ;             SVC call_write_char
00000B04:             ;             
00000B04: E2566001    ;             SUBS  r6, r6, #1
00000B08: 1AFFFFF7    ;             BNZ   output_thing1
00000B0C:             ; 
00000B0C:             ;             ; output next thread's counter
00000B0C:             ; 
00000B0C: E24F0074    ;             ADR R0, thread2_message
00000B10: EF000000    ;             SVC call_write_string
00000B14:             ; 
00000B14: E5184000    ;             LDR R4, [R8]
00000B18: E3A06008    ;             MOV   r6, #8
00000B1C:             ;         output_thing2
00000B1C: E1A00E24    ;             MOV   r0, r4, LSR #28
00000B20:             ; 
00000B20: E1A04204    ;             MOV   r4, r4, LSL #4
00000B24:             ; 
00000B24: E2800030    ;             ADD   r0, r0, #48
00000B28: E350003A    ;             CMP   r0, #58              
00000B2C: 22800007    ;             ADDHS r0, r0, #7           
00000B30: EF000001    ;             SVC call_write_char
00000B34:             ;             
00000B34: E2566001    ;             SUBS  r6, r6, #1
00000B38: 1AFFFFF7    ;             BNZ   output_thing2
00000B3C:             ; 
00000B3C:             ;         
00000B3C:             ;         ; check if we have correct div result
00000B3C:             ;         ; terminates if true
00000B3C: E5174000    ;         LDR R4, [R7]
00000B40: E1540005    ;         CMP R4, R5
00000B44: 0F000003    ;             SVCEQ call_hang ; stop programs if result achieved.
00000B48:             ;         
00000B48: EAFFFFDD    ;         B prog3_loop
00000B4C:             ; 
00000B4C:             ; DEFS 128
00000BCC:             ; prog3_stack

Symbol Table: Labels
: Max_SVC                           0000000F  Value
: call_write_string                 00000000  Value
: call_write_char                   00000001  Value
: call_clear_display                00000002  Value
: call_hang                         00000003  Value
: call_wait_ms                      00000004  Value
: call_load_port_B                  00000005  Value
: call_BEGIN_ATOMIC_BLOCK           00000006  Value
: call_END_ATOMIC_BLOCK             00000007  Value
: call_add_thread_to_pool           00000008  Value
: call_exit_thread                  00000009  Value
: call_yield                        0000000A  Value
: call_divider_IN_send_data         0000000B  Value
: call_divider_IN_send_inst         0000000C  Value
: call_divider_OUT_recieve_state    0000000D  Value
: call_divider_OUT_recieve_data     0000000E  Value
: INTERRUPT_enable_timer_compare    00000001  Value
: disable_interrupts                00000080  Value
: base_IO_address                   10000000  Value
: OFFSET_enable_interrupts_port     0000001C  Value
: port_B_address                    10000004  Value
: timer_compare_port                1000000C  Value
: SVC_init                          00000020  Local -- ARM
: undefined_instruction             00000068  Local -- ARM
: SVC_handler                       0000006C  Local -- ARM
: table_calc                        0000007C  Local -- ARM
: SVC_jump_table                    00000088  Local -- ARM
: SVC_0                             000000C4  Local -- ARM
: SVC_1                             000000CC  Local -- ARM
: SVC_2                             000000D4  Local -- ARM
: SVC_3                             000000E8  Local -- ARM
: SVC_4                             000000EC  Local -- ARM
: SVC_5                             000000F4  Local -- ARM
: SVC_6                             00000108  Local -- ARM
: SVC_7                             00000120  Local -- ARM
: SVC_8                             00000138  Local -- ARM
: setup_TS_keep_pushing_blank       00000154  Local -- ARM
: SVC_9                             0000017C  Local -- ARM
: LOCALTEMP_passLR                  0000018C  Local -- ARM
: LOCALTEMP_passSPSR                00000190  Local -- ARM
: SVC_10                            00000194  Local -- ARM
: HD_divider_io_base                20000000  Value
: OFFSET_HD_divider_io_control      00000006  Value
: OFFSET_HD_divider_io_result       00000004  Value
: OFFSET_HD_divider_io_state        00000006  Value
: SVC_11                            000001D8  Local -- ARM
: SVC_12                            000001EC  Local -- ARM
: SVC_13                            00000200  Local -- ARM
: SHIFT_first_half_result           00000008  Value
: SVC_14                            00000214  Local -- ARM
: SVC_exit                          00000234  Local -- ARM
: interrupt_stack_top               00000338  Local -- ARM
: supervisor_stack_top              0000053C  Local -- ARM
: TIMER_STATUS_counting             00000000  Value
: TIMER_STATUS_pause                00000001  Value
: TIMER_STATUS_reset                00000002  Value
: TIMER_DISPLAY_sec_digit_0         00000013  Value
: TIMER_DISPLAY_sec_digit_1         00000012  Value
: TIMER_DISPLAY_min_digit_0         00000007  Value
: TIMER_DISPLAY_min_digit_1         00000006  Value
: minute_passed                     0000003C  Value
: second_passed                     0000000A  Value
: hundred_ms                        00000064  Value
: TS_BUFFER_MAX_CAPACITY            00000003  Value
: TS_BUFFER_setup                   00000540  Local -- ARM
: TS_BUFFER_enqueue                 0000055C  Local -- ARM
: TS_BUFFER_dequeue                 000005A8  Local -- ARM
: TS_CIRC_BUFFER_LENGTH             000005F8  Local -- ARM
: TS_CIRC_BUFFER_HEAD               000005FC  Local -- ARM
: TS_CIRC_BUFFER_TAIL               00000600  Local -- ARM
: TS_CIRC_BUFFER                    00000684  Local -- ARM
: interrupt_active_port_offset      00000018  Value
: timer_compare_interrupt_active    00000001  Value
: timer_counter_port                10000008  Value
: FPGA_PIO_base_address             20000000  Value
: OFFSET_FPGA_PIO_kb_port_data      00000002  Value
: OFFSET_FPGA_PIO_kb_port_control   00000003  Value
: OFFSET_PIO_kb_port_IO_control     00000001  Value
: interrupt_handler                 00000688  Local -- ARM
: ISR_context_switch                000006B0  Local -- ARM
: ISR_context_switch_nosave         000006CC  Local -- ARM
: TIME_PER_THREAD                   00000002  Value
: _NEWLINE                          0000000A  Value
: _CLEAR_DISPLAY                    00000001  Value
: NEWLINE_INSTRUCTION               000000A8  Value
: BM_LED_Enable                     00000010  Value
: BM_Status                         00000080  Value
: BM_R_NOTW                         00000004  Value
: BM_RS                             00000002  Value
: BM_Enable_Interface               00000001  Value
: BM_button_upper                   00000040  Value
: BM_button_lower                   00000080  Value
: BM_svc_mode                       000000D3  Value
: BM_user_mode                      000000D0  Value
: BM_interrupt_mode                 000000D2  Value
: BM_BIC_for_usr_mode               00000004  Value
: BM_set_output_kb_matrix_wires     000000F0  Value
: BM_isolate_key_value              000000F0  Value
: BM_kb_enable_1_4_7_ASTERISK       00000080  Value
: BM_kb_enable_2_5_8_0              00000040  Value
: BM_kb_enable_3_6_9_HASH           00000020  Value
: BM_KB_top_row_pressed             00000001  Value
: BM_KB_bottom_row_pressed          00000008  Value
: BM_debounce_register_press        000000FF  Value
: BM_debounce_register_unpress      00000000  Value
: Port_A                            10000000  Value
: write_string                      00000708  Local -- ARM
: print_loop                        00000710  Local -- ARM
: end_print_loop                    00000724  Local -- ARM
: write_character                   00000728  Local -- ARM
: poll_LCD                          00000730  Local -- ARM
: write                             0000075C  Local -- ARM
: skip_newline                      0000077C  Local -- ARM
: skip_clear_display                00000788  Local -- ARM
: wait_ms                           000007A4  Local -- ARM
: poll_timer                        000007B4  Local -- ARM
: skip_wrap_case                    000007D0  Local -- ARM
: init                              000007E4  Local -- ARM
: divider_program_result            00000814  Local -- ARM
: divider_program_stack             00000918  Local -- ARM
: HD_divider_io_RESET_INSTRUCTION   00000001  Value
: HD_divider_io_STARTDIV_INSTRUCTI  00000002  Value
: HD_divider_io_state_OK            00000002  Value
: input_A                           00000918  Local -- ARM
: input_B                           0000091A  Local -- ARM
: divider_program                   0000091C  Local -- ARM
: poll_HD_divider_io                00000954  Local -- ARM
: thing2                            0000096C  Local -- ARM
: prog2                             00000970  Local -- ARM
: prog2_loop                        0000098C  Local -- ARM
: prog2_stack                       00000A98  Local -- ARM
: CSWITCH_DELAY                     0000000A  Value
: thread1_message                   00000A98  Local -- ARM
: thread2_message                   00000AA0  Local -- ARM
: expected_div_result               00000AAC  Local -- ARM
: prog3                             00000AB0  Local -- ARM
: prog3_loop                        00000AC4  Local -- ARM
: prog3_wait                        00000AC8  Local -- ARM
: output_thing1                     00000AEC  Local -- ARM
: output_thing2                     00000B1C  Local -- ARM
: prog3_stack                       00000BCC  Local -- ARM
