KMD
00000000:             ; INCLUDE ../os/OS_header.s
00000000:             ; ; v9.5
00000000:             ; ; Changelog:
00000000:             ; ; - Changed init -> SVC_init
00000000:             ; ;   - 'init' will now be a USER label, denoting the beginning of the program
00000000:             ; ;   - The user should add the threads (in an atomic block) in the init routine
00000000:             ; ;   - They should then exit the init thread.
00000000:             ; ; - Added SVCs for creating atomic block (disables interrupts)
00000000:             ; ; - Added SVC for exiting thread
00000000:             ; ; - Added SVC for creating new thread
00000000:             ; 
00000000:             ; Max_SVC EQU &10
00000000:             ; call_write_string EQU 0
00000000:             ; call_write_char EQU 1
00000000:             ; call_clear_display EQU 2
00000000:             ; call_terminate EQU 3
00000000:             ; call_wait_ms EQU 4
00000000:             ; call_load_port_B EQU 5
00000000:             ; call_BEGIN_ATOMIC_BLOCK EQU 6
00000000:             ; call_END_ATOMIC_BLOCK EQU 7
00000000:             ; call_add_thread_to_pool EQU 8
00000000:             ; call_exit_thread EQU 9
00000000:             ; 
00000000:             ; INTERRUPT_enable_timer_compare EQU 1
00000000:             ; 
00000000:             ; disable_interrupts EQU &80
00000000:             ; 
00000000:             ; base_IO_address EQU &10000000
00000000:             ; OFFSET_enable_interrupts_port EQU &1C 
00000000:             ; 
00000000:             ; port_B_address EQU &10000004
00000000:             ; timer_compare_port EQU &1000000C
00000000:             ; 
00000000:             ; 
00000000:             ; user_mode EQU &D0
00000000:             ; interrupt_mode EQU &D2
00000000:             ; 
00000000: EA000005    ; B SVC_init
00000004: EA000015    ; B undefined_instruction
00000008: EA000015    ; B SVC_handler
0000000C: E1A00000    ; NOP
00000010: E1A00000    ; NOP
00000014: E1A00000    ; NOP
00000018: EA0001A8    ; B interrupt_handler
0000001C:             ; 
0000001C:             ; SVC_init
0000001C: E28FDFD3    ;     ADRL SP, supervisor_stack_top ; set supervisor sp (R13) to top of stack allocation
00000020:             ;     
00000020: EB000154    ;     BL TS_BUFFER_setup ; set up thread stack buffer pointers to enable enqueue, dequeue
00000024:             ; 
00000024:             ;     ; switch to interrupt mode first to set up stack etc.
00000024: E3A0E0D2    ;     MOV R14, #interrupt_mode
00000028: E12FF00E    ;     MSR CPSR, R14 ; switch to interrupt mode
0000002C:             ; 
0000002C: E28FDD15    ;     ADRL SP, interrupt_stack_top ; set up interrupt mode stack
00000030:             ; 
00000030:             ; 
00000030: E3A00001    ;     MOV R0, #INTERRUPT_enable_timer_compare
00000034: E3A01201    ;     MOV R1, #base_IO_address
00000038: E281101C    ;     ADD R1, R1, #OFFSET_enable_interrupts_port
0000003C: E5010000    ;     STR R0, [R1] ; enable timer compare interrupt
00000040:             ; 
00000040:             ; 
00000040: E3A00000    ;     MOV R0, #0
00000044: E3A01000    ;     MOV R1, #0 ; reset registers to 0 for convention
00000048:             ; 
00000048: E3A0E0D0    ;     MOV R14, #user_mode ; set up user mode
0000004C: E3CEE080    ;     BIC R14, R14, #disable_interrupts  ; Clear the disable interrupts bit, thus ENABLING them.
00000050:             ;     
00000050: E16FF00E    ;     MSR SPSR, R14 ; switch to user mode
00000054: E28FEFEF    ;     ADRL R14, init ; set up entry point of user program
00000058: E28EEB01    ; 
0000005C: E1B0F00E    ;     MOVS PC, R14 ; return to user code
00000060:             ; 
00000060:             ; 
00000060:             ; undefined_instruction
00000060: EAFFFFFE    ;     B .
00000064:             ; 
00000064:             ; SVC_handler
00000064: E92D4000    ;     PUSH {LR}
00000068: E51EE004    ;     LDR R14, [LR, #-4]
0000006C: E3CEE4FF    ;     BIC R14, R14, #&FF000000
00000070:             ; 
00000070: E35E0010    ;     CMP R14, #Max_SVC
00000074:             ;     
00000074: B08FE10E    ; table_calc    ADDLT R14, PC, R14, LSL #2
00000078: B59EF004    ;     LDRLT PC, [R14, #(SVC_jump_table - (table_calc + 8))]
0000007C: EAFFFFF7    ;     B undefined_instruction
00000080: 000000A8    ; SVC_jump_table DEFW SVC_0 ; print string
00000084: 000000B0    ;                DEFW SVC_1 ; print char
00000088: 000000B8    ;                DEFW SVC_2 ; clear display
0000008C: 000000CC    ;                DEFW SVC_3 ; terminate prog
00000090: 000000D0    ;                DEFW SVC_4 ; wait variable amount of ms
00000094: 000000D8    ;                DEFW SVC_5 ; load Port B into R0.
00000098: 000000EC    ;                DEFW SVC_6 ; disable interrupts
0000009C: 00000104    ;                DEFW SVC_7 ; enable interrupts
000000A0: 0000011C    ;                DEFW SVC_8 ; add thread to pool
000000A4: 00000160    ;                DEFW SVC_9 ; exit current thread and switch to next
000000A8:             ; SVC_0
000000A8:             ;     ; print string
000000A8: EB0001A3    ;     BL write_string
000000AC: EA00002E    ;     B SVC_exit
000000B0:             ; 
000000B0:             ; SVC_1
000000B0:             ;     ; print char
000000B0: EB0001A9    ;     BL write_character
000000B4: EA00002C    ;     B SVC_exit
000000B8:             ; 
000000B8:             ; SVC_2
000000B8: E92D0001    ;     PUSH {R0}
000000BC: E3A00001    ;     MOV R0, #&01
000000C0: EB0001A5    ;     BL write_character
000000C4: E8BD0001    ;     POP {R0}
000000C8: EA000027    ;     B SVC_exit
000000CC:             ; 
000000CC:             ; SVC_3
000000CC:             ;     ; terminate program
000000CC: EAFFFFFE    ;     B .
000000D0:             ; 
000000D0:             ; SVC_4
000000D0:             ;     ; wait variable amount of ms (R0 is input)
000000D0: EB0001C0    ;     BL wait_ms
000000D4: EA000024    ;     B SVC_exit
000000D8:             ; 
000000D8:             ; SVC_5
000000D8:             ;     ; load Port B into R0
000000D8: E92D0002    ;     PUSH {R1}
000000DC: E3A01241    ;     MOV R1, #port_B_address
000000E0: E5510000    ;     LDRB R0, [R1]
000000E4: E8BD0002    ;     POP {R1}
000000E8: EA00001F    ;     B SVC_exit
000000EC:             ; 
000000EC:             ; SVC_6
000000EC:             ;     ; Disable interrupts in user mode
000000EC: E92D0001    ;     PUSH {R0}
000000F0:             ; 
000000F0: E14F0000    ;     MRS R0, SPSR
000000F4: E3800080    ;     ORR R0, R0, #disable_interrupts ; enable the 'disable interrupts' bit
000000F8: E16FF000    ;     MSR SPSR, R0
000000FC:             ; 
000000FC: E8BD0001    ;     POP {R0}
00000100: EA000019    ;     B SVC_exit ; will save the SPSR back to the CPSR allowing above^
00000104:             ; 
00000104:             ; SVC_7
00000104:             ;     ; Enable interrupts in user mode
00000104: E92D0001    ;     PUSH {R0}
00000108:             ; 
00000108: E14F0000    ;     MRS R0, SPSR
0000010C: E3C00080    ;     BIC R0, R0, #disable_interrupts ; disable the 'disable interrupts' bit
00000110: E16FF000    ;     MSR SPSR, R0
00000114:             ; 
00000114: E8BD0001    ;     POP {R0}
00000118: EA000013    ;     B SVC_exit ; will save the SPSR back to the CPSR allowing above^
0000011C:             ; 
0000011C:             ; SVC_8
0000011C:             ;     ; FUNCTION: Add program onto the context switch pool
0000011C:             ;     ; INPUT: R0 = pointer to beginning of program, R1 = pointer to program's stack
0000011C:             ;     ; OUTPUT: None
0000011C:             ;     ; DESCRIPTION: Takes program information as input and sets up information to include progra
                      ; m
0000011C:             ;     ; in context switching.
0000011C:             ;     ; This is REQUIRED to allow the program to be included in the time slicing.
0000011C:             ;     
0000011C: E92D003D    ;     PUSH {R0, R2-R5}
00000120:             ; 
00000120: E1A0500D    ;     MOV R5, SP
00000124:             ; 
00000124:             ;     ; Create a fresh user mode CPSR and store for now
00000124: E3A020D0    ;     MOV R2, #user_mode
00000128: E3C22080    ;     BIC R2, R2, #disable_interrupts ; enable interrupts so the user program can be context swit
                      ; ched
0000012C:             ; 
0000012C:             ;     ; -------------- SETUP thread stack for program --------------
0000012C: E1A0D001    ;     MOV SP, R1 ; SP = program's stack that was input
00000130:             ; 
00000130: E3A03000    ;     MOV R3, #0
00000134: E3A0400F    ;     MOV R4, #15
00000138:             ;     ; Push blank (0) data for R0-R14 incl.
00000138:             ;     setup_TS_keep_pushing_blank
00000138: E92D0008    ;         PUSH {R3}
0000013C: E2544001    ;         SUBS R4, R4, #1
00000140: 1AFFFFFC    ;         BNE setup_TS_keep_pushing_blank
00000144:             ; 
00000144:             ; 
00000144: E92D0001    ;     PUSH {R0} ; push pointer to beginning of program as the PC value
00000148: E92D0004    ;     PUSH {R2} ; push CPSR
0000014C:             ; 
0000014C: E1A0000D    ;     MOV R0, SP ; Input of R0 is OVERWRITTEN (restored by the stack pop though)
00000150: EB00010F    ;     BL TS_BUFFER_enqueue ; enqueue updated SP of prog2
00000154:             ;     ; --------------- END SETUP  ----------------
00000154:             ; 
00000154: E1A0D005    ;     MOV SP, R5 ; restore back to svc stack
00000158:             ; 
00000158: E8BD003D    ;     POP {R0, R2-R5}
0000015C: EA000002    ;     B SVC_exit
00000160:             ; 
00000160:             ; SVC_9
00000160:             ;     ; exit current thread
00000160:             ;     ; This is done by moving into interrupt mode, branching to the context switch BUT
00000160:             ;     ; skipping the 'state saving' part of the switch.
00000160:             ;     ; Effectively switch to next thread without saving (and enqueueing) 
00000160:             ;     ; current one, therefore 'ending' it.
00000160:             ; 
00000160: E3A0E0D2    ;     MOV R14, #interrupt_mode
00000164: E12FF00E    ;     MSR CPSR, R14 ; switch to interrupt mode
00000168:             ; 
00000168: EA000164    ;     B ISR_context_switch_nosave
0000016C:             ;     ; no need for BL as we're not coming back
0000016C:             ; 
0000016C:             ;     ; no need for SVC_exit as the above branch will restore the state of the next available thr
                      ; ead.
0000016C:             ; 
0000016C:             ; 
0000016C:             ; SVC_exit
0000016C: E8FD8000    ;     POP {PC}^
00000170:             ; 
00000170:             ; 
00000170:             ; DEFS 512
00000370: 00000000    ; supervisor_stack_top DEFW 0
00000374:             ; 
00000374:             ; DEFS 512
00000574: 00000000    ; interrupt_stack_top DEFW 0
00000578:             ; 
00000578:             ; INCLUDE interrupts.s ; contains interrupt handler & routines
00000578:             ; ; v9.5
00000578:             ; ; Changelog:
00000578:             ; ; - Added ISR_context_switch_nosave label (used for exiting a thread)
00000578:             ; ; - Added context switching using thread's own stack to save its registers
00000578:             ; 
00000578:             ; 
00000578:             ; 
00000578:             ; INCLUDE timer_constants.s ; for timer status variables, minute/second times, etc.
00000578:             ; ; v7.0
00000578:             ; 
00000578:             ; TIMER_STATUS_counting EQU 0
00000578:             ; TIMER_STATUS_pause    EQU 1
00000578:             ; TIMER_STATUS_reset    EQU 2
00000578:             ; 
00000578:             ; TIMER_DISPLAY_sec_digit_0 EQU 19
00000578:             ; TIMER_DISPLAY_sec_digit_1 EQU 18
00000578:             ; 
00000578:             ; TIMER_DISPLAY_min_digit_0 EQU 7
00000578:             ; TIMER_DISPLAY_min_digit_1 EQU 6
00000578:             ; 
00000578:             ; minute_passed EQU 60
00000578:             ; second_passed EQU 10
00000578:             ; hundred_ms EQU 100
00000578:             ; INCLUDE ts_circ_buffer_util.s ; Functions & data for the thread stack pointer queue
00000578:             ; ; v1.0
00000578:             ; 
00000578:             ; 
00000578:             ; TS_BUFFER_MAX_CAPACITY EQU 3
00000578:             ; 
00000578:             ; TS_BUFFER_setup
00000578:             ;     ; FUNCTION: Setup pointers for TS buffer
00000578:             ;     ; Description: Should be called at OS setup stage.
00000578: E92D4003    ;     PUSH {R0-R1, LR}
0000057C:             ; 
0000057C:             ;     ; Set up pointers
0000057C: E28F0F4E    ;     ADRL R0, TS_CIRC_BUFFER
00000580: E28F10AC    ;     ADR R1, TS_CIRC_BUFFER_HEAD
00000584: E5010000    ;     STR R0, [R1]
00000588: E28F10A8    ;     ADR R1, TS_CIRC_BUFFER_TAIL
0000058C: E5010000    ;     STR R0, [R1]
00000590:             ; 
00000590: E8BD8003    ;     POP {R0-R1, PC}
00000594:             ; 
00000594:             ; 
00000594:             ; TS_BUFFER_enqueue
00000594:             ;     ; FUNCTION: Enqueue a stack pointer to the thread stack buffer
00000594:             ;     ; INPUT: R0 as the pointer to enqueue
00000594:             ;     ; OUTPUT: None
00000594:             ;     ; Description: Enqueues (circularly) stack pointer to buffer. Will NOT overwrite if full.
00000594:             ; 
00000594: E92D401E    ;     PUSH {R1-R4, LR}
00000598:             ; 
00000598: E28F1090    ;     ADR R1, TS_CIRC_BUFFER_LENGTH
0000059C: E5111000    ;     LDR R1, [R1]
000005A0: E3A02003    ;     MOV R2, #TS_BUFFER_MAX_CAPACITY
000005A4: E1510002    ;     CMP R1, R2
000005A8: A8BD801E    ;         POPGE {R1-R4, PC} ; exit routine; don't enqueue if buffer is full
000005AC:             ; 
000005AC:             ;     ; ------ 1. & 2. ------
000005AC: E28F1080    ;     ADR R1, TS_CIRC_BUFFER_HEAD
000005B0: E5112000    ;     LDR R2, [R1] ; load pointer from TS_CIRC_BUFFER_HEAD
000005B4: E4020004    ;     STR R0, [R2], #-4               ; -4 as we are word-addressing 
000005B8:             ; 
000005B8:             ;     ; ----- 3. ------
000005B8: E28F30FC    ;     ADR R3, TS_CIRC_BUFFER
000005BC: E2434060    ;     SUB R4, R3, #(32*TS_BUFFER_MAX_CAPACITY)
000005C0: E1520004    ;     CMP R2, R4
000005C4: B1A02003    ;     MOVLT R2, R3 ; if R2 is out of range, change R2 to point back to the top (TS_CIRC_BUFFER)
000005C8:             ; 
000005C8:             ; 
000005C8: E5012000    ;     STR R2, [R1] ; Store new head pointer back to TS_CIRC_BUFFER_HEAD
000005CC:             ; 
000005CC: E28F105C    ;     ADR R1, TS_CIRC_BUFFER_LENGTH
000005D0: E5112000    ;     LDR R2, [R1]
000005D4: E2822001    ;     ADD R2, R2, #1 ; +1 to amount of enqueued items (length)
000005D8: E5012000    ;     STR R2, [R1]
000005DC:             ; 
000005DC:             ;     
000005DC: E8BD801E    ;     POP {R1-R4, PC}
000005E0:             ; 
000005E0:             ; TS_BUFFER_dequeue
000005E0:             ;     ; FUNCTION: Dequeue thread stack pointer
000005E0:             ;     ; INPUT: None
000005E0:             ;     ; OUTPUT: R0 overwritten with next thread stack pointer
000005E0:             ; 
000005E0: E92D401E    ;     PUSH {R1-R4, LR}
000005E4:             ; 
000005E4: E28F1044    ;     ADR R1, TS_CIRC_BUFFER_LENGTH
000005E8: E5111000    ;     LDR R1, [R1]
000005EC: E3A02000    ;     MOV R2, #0
000005F0: E1510002    ;     CMP R1, R2
000005F4:             ;         ; Return 0 (empty value) if queue is empty
000005F4: 03A00000    ;         MOVEQ R0, #0 ; Return value of 0 as a default
000005F8: 08BD801E    ;         POPEQ {R1-R4, PC} ; exit routine early to avoid code below
000005FC:             ; 
000005FC:             ;     ; ------ 1. & 2. ------
000005FC: E28F1034    ;     ADR R1, TS_CIRC_BUFFER_TAIL
00000600: E5112000    ;     LDR R2, [R1] ; load pointer from TS_CIRC_BUFFER_TAIL
00000604: E4120004    ;     LDR R0, [R2], #-4
00000608:             ; 
00000608:             ;     ; ----- 3. ------
00000608: E28F30AC    ;     ADR R3, TS_CIRC_BUFFER
0000060C: E2434060    ;     SUB R4, R3, #(32*TS_BUFFER_MAX_CAPACITY)
00000610: E1520004    ;     CMP R2, R4
00000614: B1A02003    ;     MOVLT R2, R3 ; if R2 is out of range, change R2 to point back to the top (TS_CIRC_BUFFER)
00000618:             ;     
00000618:             ; 
00000618: E5012000    ;     STR R2, [R1] ; Store new tail pointer back to TS_CIRC_BUFFER_TAIL
0000061C:             ; 
0000061C: E28F100C    ;     ADR R1, TS_CIRC_BUFFER_LENGTH
00000620: E5112000    ;     LDR R2, [R1]
00000624: E2422001    ;     SUB R2, R2, #1 ; -1 to amount of enqueued items (length)
00000628: E5012000    ;     STR R2, [R1]
0000062C:             ; 
0000062C: E8BD801E    ;     POP {R1-R4, PC}
00000630:             ; 
00000630: 00000000    ; TS_CIRC_BUFFER_LENGTH DEFW 0
00000634: 00000000    ; TS_CIRC_BUFFER_HEAD DEFW 0
00000638: 00000000    ; TS_CIRC_BUFFER_TAIL DEFW 0
0000063C:             ; DEFS 128
000006BC: 00000000    ; TS_CIRC_BUFFER DEFW 0
000006C0:             ; 
000006C0:             ; interrupt_active_port_offset EQU &18
000006C0:             ; timer_compare_interrupt_active EQU &1
000006C0:             ; timer_counter_port EQU &10000008
000006C0:             ; 
000006C0:             ; FPGA_PIO_base_address EQU &2000_0000
000006C0:             ; OFFSET_FPGA_PIO_kb_port_data EQU &2
000006C0:             ; OFFSET_FPGA_PIO_kb_port_control EQU &3
000006C0:             ; 
000006C0:             ; OFFSET_PIO_kb_port_IO_control EQU 1
000006C0:             ; 
000006C0:             ; 
000006C0:             ; interrupt_handler
000006C0: E24EE004    ;     SUB LR, LR, #4 ; LR points ahead when interrupt happens so we need to correct it
000006C4: E92D4003    ;     PUSH {R0-R1, LR}
000006C8:             ; 
000006C8:             ;     
000006C8: E3A00201    ;     MOV R0, #base_IO_address ; from OS_header.s, which this must be included into
000006CC: E2800018    ;     ADD R0, R0, #interrupt_active_port_offset
000006D0: E5501000    ;     LDRB R1, [R0]
000006D4:             ; 
000006D4: E2111001    ;     ANDS R1, R1, #timer_compare_interrupt_active
000006D8: 18BD4003    ;         POPNE {R0-R1, LR} ; restore registers to be saved for context switch
000006DC: 1A000000    ;         BNE ISR_context_switch ; no link as we want to preserve LR_irq (user prog PC)
000006E0:             ; 
000006E0: E8FD8003    ;     POP {R0-R1, PC}^ ; restore & return
000006E4:             ; 
000006E4:             ; 
000006E4:             ; ISR_context_switch
000006E4:             ;     ; Set up timer for next interrupt and execute context switch
000006E4:             ; 
000006E4:             ;     ; get user SP
000006E4: E96D2000    ;     PUSH {SP}^
000006E8: E51DD000    ;     LDR SP, [SP]
000006EC:             ; 
000006EC: E96D7FFF    ;     PUSH {R0-LR}^ ; store R0-LR_usr onto the user program's stack
000006F0: E14F0000    ;     MRS R0, SPSR ; get user's CPSR
000006F4: E92D4001    ;     PUSH {R0, LR} ; store CPSR and PC to return to (LR_irq)
000006F8:             ; 
000006F8: E1A0000D    ;     MOV R0, SP
000006FC: EBFFFFA4    ;     BL TS_BUFFER_enqueue ; enqueue this thread stack for later
00000700:             ; 
00000700:             ;     ISR_context_switch_nosave
00000700:             ;         ; Why have this label?
00000700:             ;         ; This label enables us to skip the 'state saving' section of the context switch.
00000700:             ;         ; It is used when we want to CLOSE a thread (therefore never switch to it again).
00000700:             ;         ; Thus we do NOT save the thread's info back, we just switch to another.
00000700:             ; 
00000700:             ; 
00000700:             ;     ; -------------- SETUP NEXT CONTEXT SWITCH INTERRUPT -----------
00000700:             ; 
00000700:             ;     TIME_PER_THREAD EQU 2;ms
00000700:             ; 
00000700: E3A012C1    ;     MOV R1, #timer_compare_port
00000704: E5510000    ;     LDRB R0, [R1] ; load current time
00000708: E2800002    ;     ADD R0, R0, #TIME_PER_THREAD ; add ms to wait for
0000070C: E5410000    ;     STRB R0, [R1]
00000710:             ; 
00000710:             ; 
00000710:             ;     ; ACKNOWLEDGE THE TIMER INTERRUPT
00000710: E3A00201    ;     MOV R0, #base_IO_address ; from OS_header.s, which this will be included into
00000714: E2800018    ;     ADD R0, R0, #interrupt_active_port_offset
00000718: E5501000    ;     LDRB R1, [R0]
0000071C: E3C11001    ;     BIC R1, R1, #timer_compare_interrupt_active ; clear timer interrupt bit
00000720: E5401000    ;     STRB R1, [R0]
00000724:             ;     ; STORE ACKNOWLEDGEMENT
00000724:             ; 
00000724:             ;     ; -------------- End of Setup -----------
00000724:             ; 
00000724:             ;     
00000724:             ;     ; -------------- Restore next thread's state ----------------
00000724: EBFFFFAD    ;     BL TS_BUFFER_dequeue ; R0 = new thread stack
00000728: E1A0D000    ;     MOV SP, R0
0000072C:             ; 
0000072C: E8BD4001    ;     POP {R0, LR} ; get SPSR, PC to return to
00000730: E16FF000    ;     MSR SPSR_cxsf, R0
00000734: E8FD7FFF    ;     POP {R0-LR}^ ; pop R0-LR_usr 
00000738:             ; 
00000738: E1B0F00E    ;     MOVS PC, LR ; return PC to new thread and restore its status
0000073C:             ; INCLUDE standard_io.s
0000073C:             ; ; v7.0
0000073C:             ; ; Changelog:
0000073C:             ; ; - Changed write_char so that the input, R0, holds the ASCII value and not a pointer to an ASC
                      ; II value
0000073C:             ; ; - Changed write_string to accommodate above change
0000073C:             ; 
0000073C:             ; INCLUDE character_definitions.s 
0000073C:             ; ; v3.0
0000073C:             ; ; Changelog:
0000073C:             ; _NEWLINE EQU &0A
0000073C:             ; _CLEAR_DISPLAY EQU &01
0000073C:             ; NEWLINE_INSTRUCTION EQU &A8
0000073C:             ; ; includes special characters such as NEWLINE for translation to an LCD newline
0000073C:             ; 
0000073C:             ; INCLUDE bit_mask_definitions.s
0000073C:             ; ; v7.0
0000073C:             ; ; Changelog:
0000073C:             ; ; - Add system mode bm
0000073C:             ; ; - Added BM_debounce_register_press & unpress. These are for the values to check our shifting 
                      ; byte-buffers, 
0000073C:             ; ;       to see if we consider a button pressed or unpressed. 
0000073C:             ; 
0000073C:             ; BM_LED_Enable EQU &10 ; Bit for enabling/disabling LEDs on board
0000073C:             ; BM_Status EQU &80     ; Status, bit 7, of port A
0000073C:             ; BM_R_NOTW EQU &4      ; R/-W of port B
0000073C:             ; BM_RS EQU &2          ; RS of port B
0000073C:             ; BM_Enable_Interface EQU &1 ; Enable bit of port B
0000073C:             ; BM_button_upper EQU &40 ; Upper button enable bit of port B
0000073C:             ; BM_button_lower EQU &80 ; Lower button enable bit of port B
0000073C:             ; 
0000073C:             ; BM_system_mode EQU &1F
0000073C:             ; BM_interrupt_mode EQU &12
0000073C:             ; BM_BIC_for_usr_mode EQU &4
0000073C:             ; 
0000073C:             ; BM_set_output_kb_matrix_wires EQU &F0
0000073C:             ; BM_isolate_key_value EQU &F0
0000073C:             ; BM_kb_enable_1_4_7_ASTERISK EQU &80
0000073C:             ; BM_kb_enable_2_5_8_0 EQU &40
0000073C:             ; BM_kb_enable_3_6_9_HASH EQU &20
0000073C:             ; 
0000073C:             ; BM_KB_top_row_pressed EQU &1
0000073C:             ; BM_KB_bottom_row_pressed EQU &8
0000073C:             ; 
0000073C:             ; BM_debounce_register_press EQU &FF
0000073C:             ; BM_debounce_register_unpress EQU &00
0000073C:             ; ; includes bit masks for port A/B configuration
0000073C:             ; 
0000073C:             ; Port_A EQU &10000000
0000073C:             ; timer_counter_port EQU &10000008
0000073C:             ; 
0000073C:             ; ; --------------- FUNCTIONS -----------------
0000073C:             ; write_string
0000073C:             ;     ; CHANGED (22nd March, 2023, Exercise 7): Change write_string to use write_char with R0 val
                      ; ue (not pointer)
0000073C:             ;     ; DESCRIPTION: Takes a pointer to a string and outputs it entirely, stopping when a 0 is fo
                      ; und. Uses 'write_character'.
0000073C:             ;     ; INPUT: R0 = Pointer to first char of string.
0000073C:             ;     ; All registers are restored after usage (including original inputs)
0000073C: E92D4003    ;     PUSH {R0, R1, LR}
00000740:             ; 
00000740: E1A01000    ;     MOV R1, R0 ; R1 is now going to be used as a pointer to the char to print
00000744:             ;     
00000744:             ;     print_loop 
00000744: E4D10001    ;         LDRB R0, [R1], #1    
00000748: E3500000    ;         CMP R0, #0
0000074C: 0A000001    ;         BEQ end_print_loop ; end of string
00000750: EB000001    ;         BL write_character
00000754: EAFFFFFA    ;         B print_loop
00000758:             ;     end_print_loop
00000758:             ; 
00000758: E8BD8003    ;     POP  {R0, R1, PC}
0000075C:             ; 
0000075C:             ; write_character
0000075C:             ;     ; CHANGED (22nd March, 2023, Exercise 7): Change write_char input R0 to hold char value (no
                      ; t pointer)
0000075C:             ;     ; DESCRIPTION: Takes an ASCII character and outputs to the LCD display.
0000075C:             ;     ; INPUT: R0 = character value
0000075C:             ;     ; All registers are restored after usage (including original inputs)
0000075C: E92D41FE    ;     PUSH {R1-R8, LR}
00000760:             ; 
00000760: E3A04201    ;     MOV R4, #Port_A
00000764:             ; 
00000764:             ;     poll_LCD
00000764: E5D41004    ;         LDRB R1, [R4, #4]
00000768: E3811004    ;         ORR R1, R1, #BM_R_NOTW ;  R/-W = 1
0000076C: E3C11002    ;         BIC R1, R1, #BM_RS ; RS=0
00000770:             ; 
00000770:             ; 
00000770: E3811001    ;         ORR R1, R1, #BM_Enable_Interface  ; E = 1
00000774: E5C41004    ;         STRB R1, [R4, #4]
00000778:             ; 
00000778: E5545000    ;         LDRB R5, [R4]   ; Load A into R5
0000077C:             ; 
0000077C: E3C11001    ;         BIC R1, R1, #BM_Enable_Interface  ; E = 0
00000780: E5C41004    ;         STRB R1, [R4, #4]
00000784:             ; 
00000784: E2053080    ;         AND R3, R5, #BM_Status ; check the status, bit 7
00000788:             ; 
00000788: E3530000    ;         CMP R3, #0 ; Compare to see if status is clear
0000078C: 1AFFFFF4    ;         BNE poll_LCD   ; bit 7 of status byte is high
00000790:             ; 
00000790:             ;     write
00000790: E3811002    ;         ORR R1, R1, #BM_RS ; RS=1
00000794: E3C11004    ;         BIC R1, R1, #BM_R_NOTW ; R/-W =bit 0
00000798: E5C41004    ;         STRB R1, [R4, #4]
0000079C:             ; 
0000079C:             ;         ;LDRB R6, [R0] ; Load character from pointer
0000079C:             ;         ; CHANGED (22nd March, 2023, Exercise 7): Change write_char input R0 to hold char value
                      ;  (not pointer)
0000079C:             ; 
0000079C: E1A06000    ;         MOV R6, R0 ; copy input character
000007A0:             ; 
000007A0: E356000A    ;         CMP R6, #_NEWLINE ; ASCII NEWLINE, needs to replaced with LCD's newline instruction
000007A4: 1A000001    ;         BNE skip_newline
000007A8:             ;             ; We have a new line character
000007A8: E3A060A8    ;             MOV R6, #NEWLINE_INSTRUCTION
000007AC: E3C11002    ;             BIC R1, R1, #BM_RS ; RS = 0, write to control register to set cursor
000007B0:             ;         skip_newline
000007B0:             ; 
000007B0: E3560001    ;         CMP R6, #_CLEAR_DISPLAY ; 0x01
000007B4: 1A000000    ;         BNE skip_clear_display
000007B8:             ;             ; We have a clear display instruction
000007B8: E3C11002    ;             BIC R1, R1, #BM_RS ; RS = 0, write to control register to send instruction
000007BC:             ; 
000007BC:             ;         skip_clear_display
000007BC: E5446000    ;         STRB R6, [R4] ; put char from R6 in Port_A
000007C0:             ; 
000007C0: E3811001    ;         ORR R1, R1, #BM_Enable_Interface ; E = 1
000007C4: E3C11010    ;         BIC R1, R1, #BM_LED_Enable ; LED ENABLE = 0
000007C8: E5C41004    ;         STRB R1, [R4, #4] ; Store R1 with E=1
000007CC:             ; 
000007CC: E3C11001    ;         BIC R1, R1, #BM_Enable_Interface ; E =0
000007D0: E5C41004    ;         STRB R1, [R4, #4]
000007D4:             ; 
000007D4: E8BD81FE    ;     POP {R1-R8, PC}
000007D8:             ; 
000007D8:             ; 
000007D8:             ; wait_ms
000007D8:             ;     ; DESCRIPTION: Waits a variable amount of ms
000007D8:             ;     ; INPUT: R0 is the amount of ms to wait
000007D8: E92D407F    ;     PUSH {R0-R6, LR}
000007DC: E3A06281    ;     MOV R6, #timer_counter_port
000007E0: E1A05000    ;     MOV R5, R0 ; R5 <= time to wait in ms
000007E4:             ; 
000007E4:             ;     ; R0 = 'previous time'
000007E4:             ;     ; R1 = 'currently polled time'
000007E4:             ;     ; R3 = current diff
000007E4:             ;     ; R4 = counts total (we stop when >=R5)
000007E4: E5560000    ;     LDRB R0, [R6]
000007E8:             ;     poll_timer
000007E8: E5561000    ;         LDRB R1, [R6] ; load current time into R1
000007EC:             ;         
000007EC: E0413000    ;         SUB R3, R1, R0 ; By default, R3 = current_time-prev_time
000007F0: E1500001    ;         CMP R0, R1
000007F4:             ;         
000007F4:             ; 
000007F4:             ;         ; If R0 > R1, we have wrapped around
000007F4: DA000002    ;         BLE skip_wrap_case            
000007F8:             ;             ; time diff is 255-prev_time + current_time as it's wrapped around
000007F8: E3A030FF    ;             MOV R3, #255
000007FC: E0433000    ;             SUB R3, R3, R0 ; R3=255-prev_time
00000800: E0833001    ;             ADD R3, R3, R1 ; R3 += current_time
00000804:             ; 
00000804:             ;         skip_wrap_case
00000804: E0844003    ;         ADD R4, R4, R3
00000808:             ; 
00000808: E1A00001    ;         MOV R0, R1 ; current time saved to prev_time for next iteration
0000080C: E1540005    ;         CMP R4, R5
00000810: BAFFFFF4    ;         BLT poll_timer
00000814:             ;         
00000814:             ; 
00000814: E8BD807F    ;     POP {R0-R6, PC}
00000818:             ; 
00000818:             ; 
00000818:             ; 
00000818:             ; 
00000818:             ; 
00000818:             ; 
00000818:             ; init
00000818: EF000006    ;     SVC call_BEGIN_ATOMIC_BLOCK ; don't want to be interrupted while setting up the threads
0000081C:             ; 
0000081C: E28F0F4A    ;     ADRL R0, prog1
00000820: E28F1F49    ;     ADRL R1, prog1_stack
00000824: EF000008    ;     SVC call_add_thread_to_pool ; add prog1 to thread pool to allow context switching to it
00000828:             ; 
00000828:             ; 
00000828: E28F0F53    ;     ADRL R0, prog2
0000082C: E28F1E27    ;     ADRL R1, prog2_stack
00000830: EF000008    ;     SVC call_add_thread_to_pool ; add prog2 to thread pool to allow context switching to it
00000834:             ; 
00000834: E28F0F9F    ;     ADRL R0, prog3
00000838: E28F1FFF    ;     ADRL R1, prog3_stack
0000083C: EF000008    ;     SVC call_add_thread_to_pool ; add prog3
00000840:             ;   
00000840:             ; 
00000840: EF000007    ;     SVC call_END_ATOMIC_BLOCK
00000844:             ; 
00000844: EF000009    ;     SVC call_exit_thread ; throw away setup thread
00000848:             ; 
00000848:             ; 
00000848:             ; INCLUDE program1.s
00000848: 00000000    ; thing1 DEFW 0
0000084C:             ; 
0000084C:             ; DEFS 256
0000094C:             ; prog1_stack
0000094C:             ; 
0000094C:             ; 
0000094C:             ; prog1
0000094C: E24FD008    ;     ADRL SP, prog1_stack
00000950: E24F0E11    ;     ADR R0, thing1
00000954:             ; 
00000954:             ;     ; some magic numbers to illustrate register state preservation
00000954: E3A03003    ;     MOV R3, #3
00000958: E3A04004    ;     MOV R4, #4
0000095C: E3A05005    ;     MOV R5, #5
00000960:             ; 
00000960: E3A08008    ;     MOV R8, #8
00000964:             ; 
00000964:             ;     prog1_NUM_TO_STOP_AT EQU &10000
00000964:             ; 
00000964:             ;     prog1_loop
00000964: E2811001    ;         ADD R1, R1, #1
00000968: E5001000    ;         STR R1, [R0]
0000096C: E3310801    ;         TEQ R1, #prog1_NUM_TO_STOP_AT
00000970: 1AFFFFFB    ;         BNE prog1_loop
00000974: EF000009    ;     SVC call_exit_thread
00000978:             ; 
00000978:             ; INCLUDE program2.s
00000978: 00000000    ; thing2 DEFW 0
0000097C:             ; prog2
0000097C: E28FDE12    ;     ADRL SP, prog2_stack
00000980: E24F0010    ;     ADR R0, thing2
00000984:             ; 
00000984:             ;     ; some magic numbers to illustrate register state preservation
00000984: E3A0200A    ;     MOV R2, #10
00000988: E3A0300B    ;     MOV R3, #11
0000098C: E3A0400C    ;     MOV R4, #12
00000990: E3A0500D    ;     MOV R5, #13
00000994:             ; 
00000994: E3A0800F    ;     MOV R8, #15 
00000998:             ; 
00000998:             ;     prog2_loop
00000998: E2811001    ;         ADD R1, R1, #1
0000099C: E5001000    ;         STR R1, [R0]
000009A0: EAFFFFFC    ;         B prog2_loop
000009A4:             ; 
000009A4:             ; DEFS 256
00000AA4:             ; prog2_stack
00000AA4:             ; INCLUDE program3.s
00000AA4: 54 68 72 65 ; thread1_message DEFB "Thread1:\0"
00000AA8: 61 64 31 3A ; 
00000AAC: 00          ; 
00000AAD: 0A 54 68 72 ; thread2_message DEFB "\nThread2:\0"
00000AB1: 65 61 64 32 ; 
00000AB5: 3A 00       ; 
00000AB8:             ; ALIGN
00000AB8:             ; 
00000AB8:             ; prog3
00000AB8: E28FDF5F    ;     ADRL SP, prog3_stack
00000ABC: E3A03A02    ;     MOV R3, #&2000
00000AC0: E24F7D0A    ;     ADR R7, thing1
00000AC4: E24F8F55    ;     ADR R8, thing2
00000AC8:             ; 
00000AC8:             ; 
00000AC8:             ; 
00000AC8:             ;     prog3_loop
00000AC8: E2533001    ;         SUBS R3, R3, #1
00000ACC: 1AFFFFFD    ;         BNE prog3_loop
00000AD0: E3A03A02    ;         MOV R3, #&2000
00000AD4:             ;             ; interrupts disabled, cannot be context-switched here
00000AD4: EF000002    ;             SVC call_clear_display
00000AD8:             ; 
00000AD8: E24F003C    ;             ADR R0, thread1_message
00000ADC: EF000000    ;             SVC call_write_string
00000AE0:             ; 
00000AE0:             ;             ; dirty binary to ASCII hex code from internet: 
00000AE0:             ;             ; https://stackoverflow.com/questions/53400875/converting-integer-to-hex-string-in-
                      ; arm-assembly
00000AE0: E5174000    ;             LDR R4, [R7]
00000AE4: E3A06008    ;             MOV   r6, #8
00000AE8:             ;         loop214
00000AE8: E1A00E24    ;             MOV   r0, r4, LSR #28
00000AEC:             ; 
00000AEC: E1A04204    ;             MOV   r4, r4, LSL #4
00000AF0:             ; 
00000AF0: E2800030    ;             ADD   r0, r0, #48
00000AF4: E350003A    ;             CMP   r0, #58              
00000AF8: 22800007    ;             ADDHS r0, r0, #7           
00000AFC: EF000001    ;             SVC call_write_char
00000B00:             ;             
00000B00: E2566001    ;             SUBS  r6, r6, #1
00000B04: 1AFFFFF7    ;             BNZ   loop214
00000B08:             ; 
00000B08:             ;             ; output next thread's counter
00000B08:             ; 
00000B08: E24F0063    ;             ADR R0, thread2_message
00000B0C: EF000000    ;             SVC call_write_string
00000B10:             ; 
00000B10: E5184000    ;             LDR R4, [R8]
00000B14: E3A06008    ;             MOV   r6, #8
00000B18:             ;         loop215
00000B18: E1A00E24    ;             MOV   r0, r4, LSR #28
00000B1C:             ; 
00000B1C: E1A04204    ;             MOV   r4, r4, LSL #4
00000B20:             ; 
00000B20: E2800030    ;             ADD   r0, r0, #48
00000B24: E350003A    ;             CMP   r0, #58              
00000B28: 22800007    ;             ADDHS r0, r0, #7           
00000B2C: EF000001    ;             SVC call_write_char
00000B30:             ;             
00000B30: E2566001    ;             SUBS  r6, r6, #1
00000B34: 1AFFFFF7    ;             BNZ   loop215
00000B38:             ; 
00000B38: EAFFFFE2    ;         B prog3_loop
00000B3C:             ; 
00000B3C:             ; DEFS 256
00000C3C:             ; prog3_stack

Symbol Table: Labels
: Max_SVC                           00000010  Value
: call_write_string                 00000000  Value
: call_write_char                   00000001  Value
: call_clear_display                00000002  Value
: call_terminate                    00000003  Value
: call_wait_ms                      00000004  Value
: call_load_port_B                  00000005  Value
: call_BEGIN_ATOMIC_BLOCK           00000006  Value
: call_END_ATOMIC_BLOCK             00000007  Value
: call_add_thread_to_pool           00000008  Value
: call_exit_thread                  00000009  Value
: INTERRUPT_enable_timer_compare    00000001  Value
: disable_interrupts                00000080  Value
: base_IO_address                   10000000  Value
: OFFSET_enable_interrupts_port     0000001C  Value
: port_B_address                    10000004  Value
: timer_compare_port                1000000C  Value
: user_mode                         000000D0  Value
: interrupt_mode                    000000D2  Value
: SVC_init                          0000001C  Local -- ARM
: undefined_instruction             00000060  Local -- ARM
: SVC_handler                       00000064  Local -- ARM
: table_calc                        00000074  Local -- ARM
: SVC_jump_table                    00000080  Local -- ARM
: SVC_0                             000000A8  Local -- ARM
: SVC_1                             000000B0  Local -- ARM
: SVC_2                             000000B8  Local -- ARM
: SVC_3                             000000CC  Local -- ARM
: SVC_4                             000000D0  Local -- ARM
: SVC_5                             000000D8  Local -- ARM
: SVC_6                             000000EC  Local -- ARM
: SVC_7                             00000104  Local -- ARM
: SVC_8                             0000011C  Local -- ARM
: setup_TS_keep_pushing_blank       00000138  Local -- ARM
: SVC_9                             00000160  Local -- ARM
: SVC_exit                          0000016C  Local -- ARM
: supervisor_stack_top              00000370  Local -- ARM
: interrupt_stack_top               00000574  Local -- ARM
: TIMER_STATUS_counting             00000000  Value
: TIMER_STATUS_pause                00000001  Value
: TIMER_STATUS_reset                00000002  Value
: TIMER_DISPLAY_sec_digit_0         00000013  Value
: TIMER_DISPLAY_sec_digit_1         00000012  Value
: TIMER_DISPLAY_min_digit_0         00000007  Value
: TIMER_DISPLAY_min_digit_1         00000006  Value
: minute_passed                     0000003C  Value
: second_passed                     0000000A  Value
: hundred_ms                        00000064  Value
: TS_BUFFER_MAX_CAPACITY            00000003  Value
: TS_BUFFER_setup                   00000578  Local -- ARM
: TS_BUFFER_enqueue                 00000594  Local -- ARM
: TS_BUFFER_dequeue                 000005E0  Local -- ARM
: TS_CIRC_BUFFER_LENGTH             00000630  Local -- ARM
: TS_CIRC_BUFFER_HEAD               00000634  Local -- ARM
: TS_CIRC_BUFFER_TAIL               00000638  Local -- ARM
: TS_CIRC_BUFFER                    000006BC  Local -- ARM
: interrupt_active_port_offset      00000018  Value
: timer_compare_interrupt_active    00000001  Value
: timer_counter_port                10000008  Value
: FPGA_PIO_base_address             20000000  Value
: OFFSET_FPGA_PIO_kb_port_data      00000002  Value
: OFFSET_FPGA_PIO_kb_port_control   00000003  Value
: OFFSET_PIO_kb_port_IO_control     00000001  Value
: interrupt_handler                 000006C0  Local -- ARM
: ISR_context_switch                000006E4  Local -- ARM
: ISR_context_switch_nosave         00000700  Local -- ARM
: TIME_PER_THREAD                   00000002  Value
: _NEWLINE                          0000000A  Value
: _CLEAR_DISPLAY                    00000001  Value
: NEWLINE_INSTRUCTION               000000A8  Value
: BM_LED_Enable                     00000010  Value
: BM_Status                         00000080  Value
: BM_R_NOTW                         00000004  Value
: BM_RS                             00000002  Value
: BM_Enable_Interface               00000001  Value
: BM_button_upper                   00000040  Value
: BM_button_lower                   00000080  Value
: BM_system_mode                    0000001F  Value
: BM_interrupt_mode                 00000012  Value
: BM_BIC_for_usr_mode               00000004  Value
: BM_set_output_kb_matrix_wires     000000F0  Value
: BM_isolate_key_value              000000F0  Value
: BM_kb_enable_1_4_7_ASTERISK       00000080  Value
: BM_kb_enable_2_5_8_0              00000040  Value
: BM_kb_enable_3_6_9_HASH           00000020  Value
: BM_KB_top_row_pressed             00000001  Value
: BM_KB_bottom_row_pressed          00000008  Value
: BM_debounce_register_press        000000FF  Value
: BM_debounce_register_unpress      00000000  Value
: Port_A                            10000000  Value
: write_string                      0000073C  Local -- ARM
: print_loop                        00000744  Local -- ARM
: end_print_loop                    00000758  Local -- ARM
: write_character                   0000075C  Local -- ARM
: poll_LCD                          00000764  Local -- ARM
: write                             00000790  Local -- ARM
: skip_newline                      000007B0  Local -- ARM
: skip_clear_display                000007BC  Local -- ARM
: wait_ms                           000007D8  Local -- ARM
: poll_timer                        000007E8  Local -- ARM
: skip_wrap_case                    00000804  Local -- ARM
: init                              00000818  Local -- ARM
: thing1                            00000848  Local -- ARM
: prog1_stack                       0000094C  Local -- ARM
: prog1                             0000094C  Local -- ARM
: prog1_NUM_TO_STOP_AT              00010000  Value
: prog1_loop                        00000964  Local -- ARM
: thing2                            00000978  Local -- ARM
: prog2                             0000097C  Local -- ARM
: prog2_loop                        00000998  Local -- ARM
: prog2_stack                       00000AA4  Local -- ARM
: thread1_message                   00000AA4  Local -- ARM
: thread2_message                   00000AAD  Local -- ARM
: prog3                             00000AB8  Local -- ARM
: prog3_loop                        00000AC8  Local -- ARM
: loop214                           00000AE8  Local -- ARM
: loop215                           00000B18  Local -- ARM
: prog3_stack                       00000C3C  Local -- ARM
